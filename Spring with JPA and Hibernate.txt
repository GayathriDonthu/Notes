									Spring with JPA and Hibernate
									=============================
									
What is JPA?
------------
-> JPA - Java Persistence API, focused on Object Relational Mapping - ORM.
-> Originally JPA was part of EJB, but later available on its own.
-> Started as Hibernate and then extracted a standard interface.
-> It is ORM tool - how we map Object Oriented language Java to our replational database.
-> It is POJO based. JPA focuses on good object oriented design.
	1. XML configuration
	2. Annotation based configuration.
-> Built around patterns and best practices 
	1. Helps keep our code OO.
	2. Pluggable persistence providers
		- Hibernate
		- Toplink (before Java, developed by Smalltalk developers)
		- EclipseLink
		- OpenJPA
		
History of JPA
--------------

Hibernate 1.0 -> 2001 by Gavin King 
JDO 1.0 -> 2002 - focused on storing more than just relational databases like XML or flat files.
JPA 1.0 -> 2006 - Entity beans are heavy weight and complicated, they had to be used on application server instead of a 
			      lightweight Tomcat. Many third party features are included in JPA. Hibernate and TopLink became implementations of JPA.
JPA 2.0 -> 2009 - address features that weren't present in popular ORM vendors
Hibernate 3.0 -> 2010 -annotation based and is an implementation of JPA 2.0 specification.

-> Now, JBOSS acquired Hibernate, open source implementation, can be used on any container, doesn't have to be used with JBoss.

Problem
--------

Why we need to use HIbernate or JPA?

-> Developers don't always make good DBA's. - like not understanding foreign key constraints or how to best represent what they are trying to do in a relational database.
-> Data model doesn't line up with Object model.
-> Configuration is better with JPA, but still could be better..
	1. Transactions 
	2. Testing
	3. Datasource configuration
	
	Thease are solved by Spring and JPA.
	
-> Business focus
	Ex: we may have 40 lines of code using JDBC to retrieve details of car based on Id and assignining it to an object, but business focus is only 2 lines. There is finally block which closes connections, if not we run out of connections, out of memory or heapspace or permgen.
	
	
The Solution
------------

-> JPA removes boiler plate code.
-> Helps deveolopers to build objects and JPA bridges the gap between relational database and OO code.
-> Spring handles the configuration and transactions.
-> Code can focus on testing.
-> Transactions are transparent to the developer.
-> Annotation based development.

Business focus 

The huge JDBC code turns into below code, 

public Car find(Integer p){
	Car car = getEntiryManager().find(Car.class, p);
	
	return car;
}

Scaffold application
====================

Application build in SPring MVC course.

https://github.com/bh5k/spring_mvc_base



Prerequisites
-------------

1. Java 7 or greater
2. Maven 3.x or greater
3. Spring STS
4. Tomcat 7 or greater

Requirement:

Everytime we post to the fitnessTracker page, it just throws away the minutes added at the end of that request response life cycle. We need to flush out the rest of the way using JPA and Hibernate and Spring to configure JPA and Hibernate.

-> Bootstrap and Jetstrap were included in the downloaded application by Hansen.

persistence.xml
---------------

JPA without spring, we specify

1. datasource
2. allowed operations
3. caching

why spring?

-> Can override settings per environment
-> easier to test
-> inject into other resources

Using spring also we need empty persistence.xml file
-> src/main/resouces/META-INF/persistence.xml

Maven will keep implicitly find places anything inside te META-INF directory

persistence.xml

<persistence xmlnamespace="http://java.sun.com/xml/ns/persistence"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence_2_0.xsd"
	version="3.0">
	
	<persstence-unit name="punit">
		
	</persstence-unit>
	
</persistence>


web.xml
-------

-> for JPA we use 

1. listener inside web.xml
2. context-param
	-> name - contextConfigLocation
	-> value - classpath:/jpaContext.xml

classpath:/jpaContext.xml -> tells where on classpath to find this value, it will be at the root.

<listener>
	<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>

-> When our application starts up, the listener class is actually triggered by the container to start up the above listener. 
-> Then this looks for a context parmeter named contextConfigLocation, which in turn looks for classpath for a file named jpaContext.xml

jpaContext.xml
--------------

-> used in place of the persistence.xml
-> so all those we place inside jpaContext.xml are loaded by spring
-> jpaContext.xml ( just a standard naming convention)
-> Loaded from classpath, configured in web.xml using context loader listener.
-> Once loaded, place it in src/main/resources/jpaContext.xml
-> Contains:
	1. EntityManagerFactory
		-> JPA vendor
		-> JPA Properties
		
	2. Transaction Manager
	3. Annotation Configuration
	4. Datasource configuration or lookup


src/main/resources/ -> New -> spring bean configuration file -> jpaContext.xml

Under namespaces tab, check the context and tx

<context:annotation-config/> -> tells spring that configure rest of the application usign annotation. scan classpath and items inside the context file, inject into other beans that we have created.

bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/> -> tells spring to use the persistent context annotation.

EntityManagerFactory
--------------------

-> used to start up JPA and Hibernate inside of the application.
-> CLass "LocalContainerEntityManagerFactoryBean" is present inside that,
	1. located inside spring-orm.jar
	2. references our persistence unit.
	3. Injected datasource if one isn't defined in the persistence unit.
	4. defines what vendor(JPA provider) we are using.
	5. options to specify vendor specific JPA properties.

<property name="showSql" value="true"/> 
	-> it shows the sql that it's executing behind the scenes as we're running Hibernate.
	
<property name="jpaPropertyMap">
	-> This is where we define specific JPA vendor properties, so these are ones specific to Hibernate.	
	
<map> 
	-> similar to HashMap, like name and value pair.
	
hibernate.dialect
	-> Hibernate has specific dialects that we choose for each vendor of database that we're using. Sometimes, dialect per version.
	
hibernate.hbm2ddl.auto
	-> This is for interacting with the ddl that our database needs to work.
	
hibernate.format_sql
	-> debugging purpose
	
These properties are needed for JPA to be setup with our LocalContainerEntityManagerFactoryBean.

Transaction Manager
------------------

-> With JPA and hibernate, people work within a transaction but they don't create and start transactions ans roll them back on their own.
-> We have to wrap a trasaction manager around them.

1. JPATransactionManager
	-> takes EntityManagerFactory as a ref
	
2. Annotation Driven

3. Comes from spring-tx.jar


<bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
	<property name="entityManagerFactory" ref="entityManagerFactory"/>
</bean>

-> Makes transaction manager available for us.

<tx:annotation-driven transaction-manager="transactionManager"/>

-> To configure transactions

Datasource
----------

1. DriverManagerDataSource
	-> spring-jdbc.jar
	
2. driverClassName
	-> org.h2.Driver
	
3. url
	-> jdbc:h2:~/test
	
4. username
	-> sa
	
5. password
	-> sa

Overview of JPA and creating first entity
=========================================

JPA - JPA is an interface for a specific implementation of an ORM.
ORM - created to bridge the gap between object-oriented languages such as Java and various relations databases.
Relational database - don't have the concept of object oriented techniques. There are things we can do in our design to represent these features with the use of JPA.

What is JPA?
------------

-> It's just a specification, not an actual implementation of code.
-> JPA is an interface to ORM and ORM is an implementation of JPA.
-> We can use annotations/ xml files.
-> JPA is a specification for accessing, persisting and managing data between Java objects or classes and a relational database.
-> JPA is not SQL as it will deal with objects similar to database tables.
-> JPA uses JPQL - Java Persistence Query Language and it is dealing with POJOs and Java objects.
-> Everything inside of JPA is centered around the object ad around the specific POJO.

JPA Providers
-------------

Since JPA is just and interface for a specific provider, there are quite a few implementations.

1. BA2
2. DataNucleus
3. EclipseLink / Toplink - Hibernate and JPA have lots of concepts from toplink
4. ObjectDB
5. OpenJPA - alternative to hibernate or a competitor to Hibernate
6. Versant 
7. Hibernate

Some of them also support data warehousing like OLAP operations. Choose the provider based on business. Hibernate is most preferred.

Hibernate History
-----------------

-> Previosuly in EJBs , container-manage persistence technique was present - It drove away OO principles, hence Hibernate came
-> Sun introduced JPA , similar to Hibernate in replacement of container-manage persistence.

JPA makes easier t switch between providers.

What makes up an Entity
-----------------------

-> We need to add 2 things to POJO to make it an entity that Hibernate and JPA will work with.

1. Add @Entity annotation - class level annotation, signifies JPA that we are going to persist and use against the database.

2. Add @Id annotation - usually use long as not to run out of space.

JPA/Hibernate Configuration
----------------------------

<property name="jpaPropertyMap">
	<map>
		<entry key="hibernate.dialect" value="  org.hibernate.dialect.H2Dialect"/>
		<entry key="hibernate.hbm2ddl.auto" value="none"/>
		<entry key="hibernate.format_sql" value="true"/>
	</map>
</property>

The above code is configured in the LocalContainerEntityManagerFactoryBean, so that's where the jpaPropertyMap is located at.

1. hibernate.dialect -> is what type of vendor of database
2. hibernate.format_sql -> it means when it dumps it out in our log statements it's going to be in formatted way.
3. hbm2ddl.auto  
	-> create  - It will create database for us if we have it sent here. We need to have schema defined, but it will take all of our entities and create 
				 them in the database for us.	
	-> create-drop - It will create it when we start up our application and drop it when we are done with our application.
	-> update - update any fields that have changed, doesn't delete if anything is already added to our record.
	-> validate - run in production when we are finished working with application. It will go through and verify that what we have in database structure lines up with what our object says it is.
	-> none
	
	
Entity and JPA config
---------------------

@Entity
@Id
@GeneratedValue - it says that it's going to use the field whatever the column type is of our Id column and our database, uses an auto incrementing field. It 
				  says, id is an auto-incrementing field, it is the primary key and since it is an entity, I want Hibernate and JPA to be tracking me against the database.
				  
<entry key="hibernate.hbm2ddl.auto" value="create"/> -> creates tables and schema
				  
JPA Annotations and how to use them
===================================

@Entity - Declares the object as an entity and now the database will be aware of it.

@Table - Describes more specific details about the database, i.e., name, schema

@Id - Identifier attribute for a simple primary key type.

@GeneratedValue - used in conjunction with Id
	1. IDENTITY - used to specify a database identity column. 
					-> id is not available when returned to user after the transaction is committed.
					-> It is slower as that cannot pre-allocate Id's for inserts.
					-> Ex: autom incrementing field in mysql
					-> simpler to use
	2. AUTO - Automatically chooses an implementation based on underlying database.			
		      -> oracle don't have auto incrementing field but has sequence field
			  
	3. SEQUENCE - Works with a sequence(if db supports), @SequenceGenerator
				  -> Ex: MySQL doesn't support sequence, but Oracle, DB2 or other vendors have sequences.
				  -> we plug in the sequence using @SequenceGenerator tag annotation, it will tie that into that underlying implementation.
				  
	4. TABLE - specifies that a database will use an identity table and column to ensure uniqueness, @TableGenerator
			   -> most portable options is Table
			   -> Table will work with all implementations of databases
			   -> It uses an identity table and column to ensure uniqueness and we also have to tie this in using the TableGenerator annotation.
	
Column Annotation
-----------------

-> Till now we had columns that we hadn't specified a name yet, but they were still mapped.
-> JPA will look the name and the type of column that the object is and make assumptions about what to map it as.

@Column -> allows us to override column names and column mappings and specific attributes like below

- columnDefinition
- insertable
- length
- name
- nullable
- precision
- scale
- table
- unique
- updatable

How to use Annotations
----------------------

1. Get our entity manager injected into our code using @PersistenceContext

   @PersistenceContext - grabs an instance of our Entity Manager Factory and injects it into our code. It is called persistenceContext instead of EntityManager 
						 is because it is pertaining to a specific persistenceUnit or persistenceContext. Since, we created Entity manager and tied it to a persistence unit so it's not called as @EntityManager.
					  
2. @Service - It ties sequence of events going to our database and our repository tier.
			- service is where our business logic located at.
			
3. @Repository - spring  DAO object, database interactions occurs.

4. Transactional - annotation needed to tie whole thing together to start using
				 - used to start a transaction
				 - We have to have a transaction in process to interact with our database.
   

<context:annotation-config/> should be followed by
<context:component-scan base-package=""/>

JPA will not save until we do flush. entityManager.flush();

@Transactional should be added to start a transaction.

Join types
----------

-> JPA needs to bind the collections of objects to database. 

4 join types

1. @OneToOne
2. @OneToMany
3. @ManyToOne
4. @ManyToMany

Used in below configurations

1. Unidirectional
2. Bidirectional
3. Cascade


@OneToMany
---------

-> One to many relationship between object and a list of objects.

Ex: goal - list of exercises

-> Add @OneToMany annotation to the goal object and add list of exercises to that and map that back to the goal

@OneToMany(mappedBy = "goal", cascade=CascadeType.All)
private List<Exercise> exercises = new ArrayList<Exercise>();

mappedBY -> referring to the owning objects.

so these exercises belong to this goal or goal has a list of many exercises.


Unidirectional -> adding @OneToMany annotation to exercises list.

Bidirectional -> adding @ManyToOne annotation to goal object.

Fetch Type:
----------

When using join types, 	we can choose at what time we want to fetch that data.

There are 2 fetch types:

1. Lazy - Queries the database when that property is called.
		- It will wait until we actually call the getter to query the database.
		
2. Eage - Queries the database when the object was originally created. 


JPQL
----

-> Java Persistence Query Language - used to work with data. It is not SQL.
-> JPQL is centered around objects.

	Ex: 
	
	Query query = em.createQuery("select g from Goal g");
	
	select * from Goal is not allowed in JPQL.
	
-> The table name is case sensitive. i.e., GOAL is not allowed.

import javax.persistence.Query;

When we use fetch type as LAZY, we get errors.

To fix this,We use a class called the OpenEntityManagerInViewFilter.

It's actually a Web filter that we implement in our Web.XML. And it's how we fix the session from being closed for our request response lifecycle.

									   |	
	Controller  ------------> Service  |--------------------> Repository
									   |
									   
-> line represents where our JPA session typically starts and stops. So, it starts right after we call our service, opens up our repository tier. And then it ends when we come back to our service. 
-> Using an OpenEntityManagerInViewFilter though, we can open and close our JPS session further up in the process to here. So, we actually get rid of it being closed when we go to access things inside of like our JSP page or if we're using a FreeMarker or Velocity Template

Below is the code in web.xml, That just keeps our session open a little bit longer. And when we're inside of our JSP page we'll allow it to lazily load those objects.

<filter>
	<filter-name>SpringOpenEntityManagerInViewFilter</filter-name>
	<filter-class>org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter</filter-class>
</filter>

<filter-mapping>
	<filter-name>SpringOpenEntityManagerInViewFilter</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>

How to configure and use Spring Data JPA
========================================

-> Persist is used only for creates
-> Merge is used for updates.
-> Save methods are overridden to handle both.

-> For merge no need of calling flush(), merge returns an updated object where the persist is void. Becoz, some of the id columns aren't chosen until after the object has been saved.

Spring Data JPA
----------------

-> It is a wrapper for JPA.
-> Replaces repository Tier unless we need some custom functionality.
-> eliminates lot of boilerplate code.
-> can be extended for additional functionality.

Maven
-----

-> Add spring-data-jpa.jar
-> Spring data JPA contains incompatible trans dependency while using with Spring MVC
-> Spring data JPA can be used without Spring MVC.
-> versions in spring MVC don't line up with the latest release of Spring Data JPA.
-> If we want to use latest versions of both then exclude spring-aop.

<dependency>
	<groupId>org.springframework.data</groupId>
	<artifactId>spring-data-jpa</artifactId>
	<version>1.3.0.RELEASE</version>
	<exclusions>
		<exclusion>
			<groupId>org.springframework</groupId>
			<artifactId>spring-aop</artifactId>
		</exclusion>
	</exclusions>
</dependency>

JPA Namespace
------------

to configure use JPA namespace in jpaContext.xml file

xmlns:jpa="http://www.springframework.org/schema/data/jpa"
xsi:schemaLocation = ""http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.8.xsd"

<jpa:repositories base-package="com.pluralsight.repository"/>

Tells where to lokk for our Spring Data JPA repositories.

Exercise Repository
-------------------

1. Delete Impl
2. Extend JpaRepository Interface
3. Needs to know the class it sevices and the ID type.

@Repository("exerciseRepository")
public interface ExerciseRepository extends JpaRepository<Exercise, Long>{
}

Exercise is the class,
Long is the datatype of variable Id in Exercise class.

-> In spring data JPA, there is no support for projections yet, i.e., @NamedQueries, so need to use @Query

Exceptions:
----------

1. Request processing failed; nested exception is javax.persistence.TransactionRequiredException: No EntityManager with actual transaction available for current thread - cannot reliably process 'persist' call

Solution:

<tx:annotation-driven transaction-manager="transactionManager" />
 
 need to be present in servlet-config.xml

2. Request processing failed; nested exception is org.springframework.transaction.CannotCreateTransactionException: Could not open JPA EntityManager for transaction; nested exception is org.hibernate.exception.GenericJDBCException: Unable to acquire JDBC Connection

Solution: need to close the h2db UI





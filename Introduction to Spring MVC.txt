													Introduction to Spring MVC
													==========================

->  Spring MVC is a web application framework for developing applications using Enterprise Java or J2EE.

Which Framework?
----------------

1. Struts -> standard struts 1, outdated. Struts2 is better than original struts.
2. Tapestry -> good framework but governed by 1 person and someone at the WIM or whatever project he is working on.
            -> first heavily object-oriented or POJO-based web frameworks. 
3. Apache Wicket -> light weight framework, easier to configure than other frameworks.
4. GWT -> Google Web Toolkit is a very rich user experience framework with a steeper learning curve than other frameworks.
5. JSF -> JSF from Oracle, true standard framework for the web and J2EE as well, rich user experience. 
	   -> It comes with libraries like ice faces and rich faces and other third party components for integrating into JSF.
6. Seam -> Seam is a JSF framework from the JBoss Group that has other things integrated into it but has a little bit of tendancy to have some 		vendor lock-in associated with it. 
		-> It's nice, tight package but we stuck doing things their way. 
7. Stripes -> a very lightweight web framework that has very similar features to Spring MVC. It's a view technology framework. 
8. Spring MVC -> It is very unobtrusive framework. 
			  -> lightweight, in the sense that there's very little overhead in running it but it's very cabable, heavy duty framework. 
			  -> It puts a lot of the best practices from all of above frameworks mentioned above and combines it into Spring MVC.
			  -> Spring MVC integrates very nicely with Spring and all other capabilities that Spring has available for us to use. 
			  
What is Spring MVC?
------------------

-> Spring MVC doesn't try to niche itself for one particular type of web application. 
-> It can be RESTful-based/ JSP-based. 
-> We can use other view technologies like FreeMarker or Velocity.
-> We can use it for headless applications. 
-> We can use it as a remoting framework. 
-> All these capabilities are built into Spring MVC. 

-> Spring MVC is a web framework built around the principles od Spring.
-> interface driven design, it's very POJO based. 
-> can be unit tested very easily and it's very lightweight, very unobtrusive. 
-> It is based on a Dispatcher servlet/ Front Controller Pattern. 
-> MVC stands for Model view Controller. 
-> It doesn't weigh us down with things we don't need. 
-> Disadvantage of JSF is that it is very heavy weight and we need to do things their way.
-> SPring will just take the things we want and just use those. 
-> Spring MVC is also built from shortcomings of struts1.
-> It supports for 
	1. themes, 
	2. localization, 
	3. Restful services, 
	4. annotation based configuration. (No need of using interfaces and their code if don't want to)
	5. Seamless integration with other spring services/beans.
	

History
-------

2003 

-> Spring framework 1st milestone released. 
-> Focus was on interface-driven development and overcoming the complexities of J2EE development. 

2004 

-> 1.0 release of spring framework.
-> incorporated spring MVC and focused on other areas.
-> integration with common tools like Hibernate and .NET

2006

-> 1.26 version, Jolt productivity award, 
-> SCG/ Spring Securty integrated into the framework.
-> more spring tools

2006

-> 2.0 release, until here things were backward compatible. 

2007

-> 2.5 version, focus on annotation-driven development. 
-> Significant release, as all the configuration was done through annotations, before that it was XML heavy. 

2009

-> 3.0 and 3.1 versions, above things carried on. 
-> Can do configuration using Java, no need of using XML.


Architecture
-----------

-> Spring MVC is built on top of the Java servlet API, implemented using serlvet front controller. 
-> So, spring MVC/ struts or all otherframeworks are just servlets, they got design patterns and things wrapped around it to make it easier. 
-> We write our application on top of Spring MVC or using Spring MVC to build this entire stock. 

				CUSTOM APP
					|
					|
					|
			SPRING MVC/ Spring
					|
					|
					|
			JAVA SERVLETS/JEE


Request/Response life cycle
-----------------------------

-> We have an incoming request that hits our SERVLET FRONT CONTROLLER, just like Dispatcher servlet inside of Spring. 

Servlet Front Controller

-> It hands off the request, delegates our request over to one of our CONTROLLERS that we've set up.

Dispatcher

-> It is the router that comes in and says 
"What controller is going to handle it? I am going to delegate this request over to this controller over here."

Controller 

-> Conrtoller just routes traffic to where it's supposed to go, It says
" I'm going to handle the request and had it over at the backend."

Backend 

-> Backend could be composed of web services or a database or multiple databases or any number of things that we're gathering data from. 
-> Backend hands back a model to us. 

Model 

-> Model is our data, what we're trying to represent on our screen. 

-> Once model gets back to the controller, the controller syas, "ok, I am going to let somebody else do the rendering."
-> rendering is separate from the business logic. 
-> This is called model-view-controller design pattern. Everything is doing its own specified functionality here. 

-> At the controller, we have model or data that we're going to try and represent the UI. 
-> So, we go back to out Front Controller and it says, 
"who's going to handle this? Who's going to render the response? let's pass our model down to some view template."
-> view template can be JSP, once model goes template/JSP page, the control returns back  to our Front Controller and then return back our response to the browser.
-> The whole thing is divided into 3 parts: model, view, controller. 


  Incoming                     Delegate                       Handle
  Request                      request                        Request
-------------->   Front      ------------>   Controller    -----------------> Backend
<-------------- Controller   <---Model-----                <-----------------
  Return           ^  |       Delegate                      Create
  response         |  |       rendering                      Model
				   |  |
                   |  Model
                   |  |
                   |  |
     Return        View            Render
	 Control      Template         Response



Vocabulary
----------

1. Dispatcher Servlet -> The entry/ configuration point for the application. 
                   -> It is also the Front Controller 
	
2. Controller -> Command pattern object that handles the request and determines which view to route to and what model we should get and handles that information and hands it back and forth.
			-> Controllers are simple POJOs.

3. Request Mapping -> The url and request type that our method is tied to. 
                   -> If we accept posts or we accept gets or puts or deletes, those type of HTML protocol requests, then the Request mapping can say, "I only accept posts, I only accept gets."

4. View Resolver -> used to locate the JSP pages or whatever view technology we are using. 
				 -> We configure a view resolver and that's how Spring MVC knows when we ask for the hello page, where to actually find the hello page at.

5. Servlet-config -> it is a configuration file per DispatcherServlet.
				  -> This is where Spring knows to configure things and wire our application up.

6. POJO -> Plain Old Java Object
        -> has no arguments constructor and private member variables, exposed through getters and setters.

7. Bean -> A Spring configured POJO.
        -> It's a POJO that we've instantiated through Spring, in the Servlet-config and it's wired up to be used inside of our framework. 
			  

Summary
-------

1. J2EE based
2. Built around best practice patterns.
3. Stable release cycle.
4. Backwards/forwards compatible.
5. Very active community.
6. Lightweight and unobtrusive
7. Flexible to use with web services, Javascript UI, standard html etc


Building an Application
========================

Prerequisites:
--------------

1. JAVA ( version >= 5)
2. Maven ( version = 3)
3. Spring STS
4. Tomcat


What we are building
-------------------

-> Building app to track the minutes that you have exercised in a day. 

App feautures

1. Allow for entering minutes exercising
2. Show total minutes
3. Set goal for the day
4. Notify when gal is reached.

Getting Spring MVC
-------------------

-> Spring Web flow and Spring web services are not the same thing. 
-> Web flow is a framework built on top of web MVC. 
-> Download spring framework

spring-franework-4.3.3.RELEASE-dist.zip

Maven
-----

-> Using Maven we need only 3 dependencies:

Dependencies

1. spring-webmvc
2. servlet-api
3. jstl

Get the dependencies and use it in pom.xml

While adding dependencies in the pom.xml, 

-> scope for spring-webmvc is compile.
-> scope for servlet-api is provided( provided means don't package it with the WAR file, becoz they are already provided with tomact)
-> scope for jstl is provided.

After adding the dependencies in pom.xml, we get jar files under the Maven dependencies, those are called as transdependencies. 

Spring MVC Configuration
------------------------

There are 4 basic parts we need to configure to utilize Spring MVC in our application.

1. Configure web.xml
2. Configure servlet-config.xml
3. Add Controller
4. Add View

Controller -> is a simple Java class that's annotated

Tomcat
------

-> Tomcat is just a web container. 
-> It doesn't have app server functionality like Oracle, WebSphere. 
-> For most web applications though Tomcat is just fine. 
-> We setup Tomcat server and then FitnessTracker.war will actually reside on top of that. 

			FitnessTracker.war
					|
					|
					|
				 Tomcat 
			  Web Container

Standards
---------

src
	-> main
		-> webapp
			-> WEB-INF
				-> jsps
					-> addTime.jsp
					-> index.jsp
				-> web.xml



-> For views, we put jsp pages or any other view technology under the WEB-INF directory. 
-> The reasons are :

1. security -> don't want people to know what my filename is, we can serve with whatever filename we want. 
2. Control user experience -> don't want people to directly navigate to us. If we force them to go through my controller and through my routing, 
						      we can control their user experience, insuring that their session was set up correctly or that they are logged in,etc.
3. bookmarking/deeplinking -> these are called as breadcrumbs

-> We do this by using InternalResourceViewResolver

InternalResourceViewResolver

-> It says " when I ask for this jsp page, I am goingto find it in this directory and serve it up to them"


addTime.jsp = http://localhost:8080/fitness/addTIme 


Controllers
-----------

1. Annotation based
	-> @Controller
2. Named whatever we want
	-> typically named around business domain.
3. Path set using annotation.
	-> @RequestMapping
4. TimeController.java -> example 

Example URLs associated with Controller

http://localhost:8080/fitness/time
http://localhost:8080/fitness/addTime
http://localhost:8080/fitness/updateTime


web.xml
-------

<servlet></serlvet> -> this is the Spring MVC dispatcher servlet. 

<init-param>

-> tells exact location of the configuration file, i.e., servlet-config.xml
-> By default it creates fitTracker.xml or fitTrackerServletconfig.xml
-> It won't create for us, In web.xml we want to specify where it is and what we want it named just to be clear

<param-name>

-> The param name is contextConfigLocation in CamelCase.  

<param-value>

-> the param value is WEB_INF( caps), config and servlet-config.xml

<servlet-mapping> -> this is what routes traffic through. 

-> The servlet-name inside the <servlet-mapping> tag should be same as the servlet-name in the <servlet> tag

<url-pattern>

-> This specifies what file extensions or what path we're going to accept for our Dispatcher servlet. it is *.html. 


Namespace
---------

-> When configuring servlet-config, specifically our bean configuration or bean definitions, there's notation of namespaces.

Example: 
mvc namespace

<mvc:annotation-driven/>
<context:
>

-> This means that we are asking for specific functionality out of that MVC schema, and it's going to go through and replace theis code with more complex definition. 
-> Spring did this to simplify their configuration files, becoz it was alwyas copy and paste code. 
->  We can add these namespaces from the namespaces tab inside the servlet-config.xml by using Spring Bean configuration file in Spring Tool Suite.
-> For servlet-config.xml we have 3 namespaces

1. beans
2. context
3. mvc

-> When we select them new tabs are created with respective namespaces

<mvc:annotation-driven/>  -> this means we are going to use annotations to configure our application. 

<context:component-scan> -> this means where should we start looking for annotations at? we keep all our controllers underneath the controller
						    package. 
							com.spring.controller
							
Controller
----------

-> Add @Controller at the top of the class.
-> Add @RequestMapping at the top of the method and provide a value. We add @RequestMapping to tie this to the URL. 
Ex: @RequestMapping(value = "/greeting") -> it is tied to /greeting
-> That's what says what our URL is going to be and what method it's going to tie to.

https://localhost:8080/fitnessTracker/greeting is going to tie to this page. 

moel.addAttribute(key, value)
model.addAttribute("wish", "Hi") -> we want to shove/push some things in the model and have that displayed in our UI.

-> We need to put JSP page and the mapping for our JSP page to our controller. 
-> Model is a hash map, basic map structure, it does more than that. 
-> jsp pages are put under WEB-INF directory. 
-> When we create jsp, Spring provides the standard EL language to extract values out of our request parameters.

${greeting} -> points to the key inside the model.addAttribute

-> Those are what tied those together and that's how it knows what to grab out of the model to display on the page. 

-> We need to tell our controller which JSP page to display. So, we need to add bean in servlet-config.xml. 

There are 2 ways to configure the bean.

1. servlet-config.xml

	
	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name = "prefix" value = "/WEB-INF/jsp/"></property>
		<property name = "suffix" value = ".jsp"></property>
	</bean>


-> suffix says where my jsp page is located at and what suffix we are looking for. (value = ".jsp")

2. In the servlet-config.xml, go to namespaces tab and click 'p' - for the property namespace. 

	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" 
	 p:prefix="/WEB-INF/jsp/" p:suffix=".jsp"></bean>
	 
	 This is just shothand for calling getters and setters for prefix and suffix. 


Summary:
--------

1. COnfigured web.xml, In web.xml we added the servlet, the dispathcer servlet and told it where our configuration was at and we mapped all of our incoming requests to .html.
2. We created servlet config.xml. We added namespaces which are convinient methods for us. We also told it that we wanted to do annotation driven and set up our context component scanner. 
3. A context component scanner tells it where to start scanning and for what clases for those annotations. 
4. The first one tells us that we're doing annotation driven. 
5. The second one tells us where those annotations are at. 
6. We created internal resource which syas" where are our jsp pages at?" whenever controller asks for jsp pages, it tells where that file is located at. 
7. We created controller: added source folders, source main java and created controller under com.spring.controller. 
8. HelloController is having controller annotation and a request mapping annotation. Request mapping annotation syays what URL am I going to tie to? 
9. Inside that a method can named whatever we want.We added model object, as an incoming parameter. 
10. Inside of our model we added an attribute for greeting that's going to tie to our jsp page. And then our retun, we told it to go to the hello jsp page. 
11. we created a hello.jsp page and we pulled model here. 

Architecture
------------

-> Architecture of Spring MVC.
-> how Spring MVC fits into the overall framework of spring.

-> Parts of an application can be discussed based around the architecture or design patterns that it's using, and everybody can be on the same page without even having developed on that application before. 

MVC
----

Standard MVC pattern (image)

-> A request comes in through the view based off of some user event and then interpreted by the controller.
-> The controller can change the model or not and then it will select the view based off our action. 
-> From here, the model can update the view with database off of the user's actions. 
-> The graphic stemmed from rich client applications that were more event-based or using a design pattern called observer, observable or a subscriber-listener type design pattern. 
-> This is not applied to all software development, we usually don't have our model updating our view becoz we've gone to a page at that point. 


MVC Web 

	 -------> C <-----------
	|						|
	|						|
	|						|
	|						|
   \|/					   \|/
	M						V

-> This graphic is seen in our web applications. 
-> Our view can access our model but it usually does so through a controller. 
-> We still make a request even if it is a lightweight request through our controller to access our model. 
-> We don't have our view typically going directly against our database or our model.

Tiered Applications
--------------------

Presentation layer
 |          /|\
 |         	 |
\|/			 |
 Business Logic
 |			/|\
 |			 |
\|/			 |
   Data Layer



-> We try to build applications in tiers more now in enterprise languages, 

Reasons are:

1. Separation of concerns

-> It means that each layer is only concerned with the task that it is assigned to do. So, presentation layer is only going to have presentation type things in it, business logic will be contained in a layer, and data/ data access is going to be contained in its own separate layer. 
-> Separation of concerns is not about reuse, its about having things in the right layer so that we can re-architect them later.

2. Reusable layers.

-> It sounds similar to separation of layers but its focus is different. 
-> If we have business logic in Presentations tier, we can't easily change the presentation tier or expose a web service for example without recreating some of that logic. 
-> If we have extracted it into its appropriate tier then we are not duplicating that logic. 
-> If we do copy paste in our application then it's not in correct tier.  
-> Reusable layer means that we have a purpose and a point that we're trying to drive of - we can expose the same data in multiple ways without having to worry about it, or we can replace the presentation tier without having to re-architect the application. 

3. Maintanence/ Refactoring

-> It's the ability to change things without having those changes ripple through all of the code. 
-> If we have hibernate and we have to chnage something in UI based on a change made in hibernate. Ex: table structure. 	
-> If this is done correctly, we can change our code and not have to retest everything rather than the pieces we changed. 

Application Layers
------------------
					View
					(JSPs)
					  |
					  |
					  |
				  Controller
				 (@Controller)
					  |
					  |
					  |
			Data MOdel / Database
			     (Model object)


-> Data model - we would access using hibernate/JDBC or Spring JDBC. This layer represents the data or model of our application. 
-> Controller - interprets the user's request and selects the appropriate view based on what we've requested or what information we got back from data model. 
-> VIew - it can be JSP/ FreeMarker or Velocity.

Myth - Spring MVC is nothing to do with the database. 

-> It has model associated with this. Is model talking about database or model talking about what is framework going represent to JSP page? 
-> It's actually referring to what we are representing in our JSP page but we always have to get that information from somewhre. 

Components
----------



														-------------------> Repository
													   |	 
													   |		
		Controller  ----------------------> Service    --------------------> Repository
					<-----------------------								   |		
													   |
													   --------------------> Repository




We represent the tiers with Spring/ Spring MVC using 3 components.

1. Controller
2. Service
3. Repository													   


Controller  -> Route where we are going and interpret the user's request. 
Service -> where our business logic goes, where our transactions will probably start  if we're accessing more than one database table as well. 
Repository -> Repository is referred to as DAO or Data Access Object. They usually have a 1-1 mapping with out database table. 

Controller
---------

-> they handle our incoming request and bulding the response. 
-> the business logic may/ may not be handled here. 
-> This is where our request and response object should stop.  We dhoulsn;t hand those off to separate tiers.
-> It should grab information from the request and the response and handed over to the business logic. 
-> Works with service and repository tier for business logic and data gathering.
-> Annotated with @Controller. 
-> There are some classes that we can extend but we wither have to wire them up or annotate with controller still. 
-> Handles exceptions and routes the view accordingly. 

Service
-------

-> Annotated with @Service.
-> It describes the verbs (actions) of a system. This is what we are trying to do inside of our application. 
-> where the business logic should reside. It shouldn't bleed into repository tier. 
-> It ensures that the business object is ina valid state. 
-> where transactions often begin(2-phase commits) Ex: roll back or access web services 
-> It often has the same methods as the repository but a different focus. 
Ex: we have method 'find user by lastname' in service tier, and we have same method in repository but what we do if we do't find the user or how many people will return or what state we might return those objects in is controlled by the service tier , whereas the repository tier is just going to get that data. 

Repository
----------

-> Annotated with @Repository
-> It describes the nouns(data) of a system. focus is different from service(verbs/ actions) vs Repository(nouns/data)
-> Focused on persisting and interacting with database or basic CRUD functions.
-> One-to-one mapping with an object. 
-> Often one-to-one mapping with database table. (not always, may break into multiple tables but have only 1 object in application)

Controllers
-----------

-> Controllers  are really heart and soul of SPring MVC.
-> They are a gateway or a proxy into everything else that happens in our Spring MVC application. 

What is a controller?

-> In Spring MVC, the controller is the central concept or part of the framework. (doesn't sense like nouns/ verbs)
-> With Restful services, we begin to think of controllers in the sens of verbs or what we can do within an application. 
-> Need to think controllers as choosing what to do based on user's action or request and then the view, or the actual web page, is just a result of doing some action. 

Architecture that makes up the controller
-----------------------------------------


				Request
			------------------------->      			----------------------> 
											Controller 								Service Tier/Business Logic
            <-------------------------					<----------------------								      
				Response



-> The request comes in, it goes to a particular controller based on what the user's request was, and it will interact with some business logic.
-> The business logic is going to produce some data. 
-> It can be a web service or it could be a database or just be business logic tier, and it's going to produce some output. 
-> The output can be considered as model for UI, and service tier eventually return that model back to out UI on the response. 
-> As we come out of the web service, we're going to hand that back to the controller. 
-> COntroller decided which view is appt based on what information is returned or what happenend out of the request, and we hand it back to the user. 


Responsibilities of controller
------------------------------

1. Interpret user input and transform that input into a model
   -> So to take that info that's going to come back from business logic, service tier and build that into a model to hand back to UI.
2. Provides access to business logic 
   -> it is the gateway to business logic.
3. Determines the correct view based on the logic.
4. Interprest exceptions from the business logic / service tier and how to handle and navigate correctly from there. 
   -> If there is a business logic exception, like invalid date/ database is down, so it is send to error page rather than requesting that we add this information or correct this information on the screen. 

@Controller
----------

-> Controllers in spring MVC are very lightweight, no need of implementing an interface/ extending a class.

-> We only need 2 parts. 

1. @Controller annotation -> tells Spring MVC that this is a controller and it should be included in the available controllers for it to route the information to.
2. @RequestMapping annotation -> tells Spring which method is going to handle which request. 

-> Spring have older concrete classes that we can extend and the URL will map the class based on the controller name. It works fine and not deprecated. 
-> Controller and request mapping approach used mostly in Restful services. 

@Controller
public class HelloController {
	@RequestMapping(value="/greeting")
	public String sayHello(Model model)
}
   
Example
------

-> Creating controller in Fitness Tracker project to display the result page. 
-> A controller that will interpret our application's request called the "Minutes Controller".
-> When we go to the Minutes controller, a page should be displayed, it should allow us to enter minutes exercised and show us what the total is already. 

<context:component-scan that tells to start looking for controller underneath that directory, underneath that package. 

@Request mapping just says what URL we are going to intercept this with, what's going to tell spring MVC to drive to this method. 

http://localhost:8080/FitnessTracker/addMinutes.html

-> when we click on thi link, we got to addMinutes.html page and it wants to go though web.xml and web.xml says send everything that is *.html to our dispatcher servlet. 

  <servlet-mapping>
  	<servlet-name>fitTrackerServlet</servlet-name>
  	<url-pattern>*.html</url-pattern>
  </servlet-mapping>
  
-> Dispatcher servlet is configured using the servlet config. 
-> Servlet config says, I want to scan for all of my controllers at this location. I wan to be annotation-driven. 

<context:component-scan base-package="com.spring.controller"/>

-> Since our controller is annotative to @Contoller, it says ok, I'm going to handle that. And since, we put request mapping, it syays the method that's going to handle that. 

console output:

Mapped "{[/greeting],methods=[],params=[],headers=[],consumes=[],produces=[],custom=[]}" 
Mapped "{[/addMinutes],methods=[],params=[],headers=[],consumes=[],produces=[],custom=[]}" 

-> when server started, we have mappings for greetings and mappings for add minutes to our serlvet. So that means our Spring MVC configuration picked it up. 
-> It means that our annotations and stuff are working right, since we got mappings for this file here. 

-> From the request mapping it returns to view. (return "addMinutes";)

-> In servlet config, there is internal resource viewer that says look for JSP pages in WEB-INF directory and look for a suffix of JSp. 

<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" 
	 p:prefix="/WEB-INF/jsps/" p:suffix=".jsp"></bean>

-> (return "addMinutes";) So, we look for addMinutes.jsp underneath the directory. 
-> we go to addMInutes.jsp page and display our information here. 


Passing params
-------------


			Request   -------------------> Controller 
			(Params)						(Model)
											  |
											  |
											  |
											  |
											  |
											  |
											  |
			Response <--------------------------
			
			
-> TO be able to pass data from our JSP page to our controller, tag libraries are used, which are provided by SPring MVC.
-> We can use standard HTML input tags, but Spring provides us a tag library making it easier to interact with our controllers. 
-> We always passed HTTP parameters that have gone on the HTTP request, and those parameters can then be accesses much similar to like a hash map, where we can grab a aparameter based on its name, so every HTML element would be named. 
-> The tags that Spring provides to us take these values from our input page and either make them available to our controller through the model hash map, bind them to a specified object, or just be able to grab them off the request.
-> So, we can always pass in the HTTP servlet request into our method and access them. 
-> The model is used for both gets and posts to out web page. 
-> When we're retrieving data and setting data to it, so that incoming and outgoing are often confuses. 

@ModelAttribute
---------------

-> Model Attribute annotation is used whenever we want to send data to our controller or retrieve data from our controller that's bound to an object or represented by an object. 
-> Spring MVC does all these things by using POJOs and not using a class that's only specific to our UI, like in some other frameworks such as struts or webwork. 

1. Used with an HTTP GET -> to get data back, ex: drop down data 
2. Used with an HTTP POST -> to send data back, ex: filling form 
3. Works with POJOs -> not specifically bound with UI tier, we can use it anywhere in the code. 
4. It can also be validated with a binding result. 

<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>

-> tag libraries aren't dowonloaded every time by Java, uri is just an index into jars - to know to go download that. Downloaded in Maven dependencies.

<form:form> -> Spring form allow us to bind an object t our data that we're submitting back to our controller. 

<form:input path="minutes"/>

-> minutes is going to tie to an object with path of minutes on it. 
>>>>>>> origin/master

<td><form:input path="minutes"/></td>

Exception:
---------

java.lang.IllegalStateException: Neither BindingResult nor plain target object for bean name 'command' available as request attribute

<td><form:input path="minutes"/></td>

-> It means it doesn't know what bean to tie that minutes attribute to. 

We created a POJO i.e., 'Exercise' bean and added minutes attribute inside that as a member variable.

-> how this model attribute is mapped to the addMinutes.jsp ? 
It is using @ModelAttribute. Inside the controller, we pass model as for the method. 

public String addMinutes(@ModelAttribute ("exercise") Exercise exercise){

<form:form commandName="exercise">

The modelattribute exercise is now bound to the commandName

Views
=======

-> Views are how we display the results of what we request middle tier using Spring MVC. 
-> Restful service results is also a type of view but it not necessaily have a UI component ot it. 
-> Views are what we see in SPring MVC. Ex: jsp/jsf (spring has an api to replace the model portion of JSF, it integrates well with Spring)

Conventions
-----------

-> jsp pages placed under WEB-INF directroy ( not mandatory) so that they cannot be deep linked or bookmarked to. 
-> This way, all the requests must be directed though our application and we guarentee the user experience. 
-> We can add more subdirectories under WEB-INF, this also enables us to secure our application easier becoz we are controlling all access to it rather than to allow people to go directly to a page, we make them navigate though our framework. 
-> To find a page in the subdirectory, we use an internal resource view resolver to find that page based on the name that we return. 


Resolving a view
----------------

@Controller
public class MinutesController {
	
	@RequestMapping(value = "/addMinutes")
	public String addMinutes(@ModelAttribute ("exercise") Exercise exercise){
		
		System.out.println("exercise:"+ exercise.getMinutes());
		
		return "addMinutes";
	}               |
}					|
					|-------------------> return string that is used by the view resolver to find the JSP page named and in the location specified 
										  with our view resolver. 

-> We can also return a view object that wraps a string that is the view name as well. 




		Controller -------------------------------------------> View Resolver  -------------------------> View
                                 Model 


-> The controller can build a model, if necessary, and return that to our view resolver with the data it needed in the view.
-> We can have multiple view resolvers as well as multiple view types in the application. 

View Resolvers
--------------

image from desktop

-> There are some view resolvers provided by Spring, we can slo create custom view resolver since they just extend view resolver interface. 
-> Some view resolvers are for using teplating tools like FreeMarker or Velocity for UI. 
-> It just configures where it should be looking for those templates and then executes the binding and writes the output to them.
-> The resource bundle view is used for internationalization purposes and the tiles view is used for tiles templated layout architecture. Ex: struts
-> Content negotiating view resolver is used when returning content types from the same application. 
-> We can have multiple view resolvers configured in the app at the same time. We just need to order which one gets fired first. 


using jsp -> addMinutes.jsp -> placed under jsp subdirectory under the WEB-INF
using FreeMarker template Library(FTL) -> addMinutes.ftl -> placed under ftl folder under the WEB-INF 

-> FTL is same as JSP. 

so the return string "addMinutes" doesn't mean that it's the eact file, but it's a key yo that file. By following below convention we can find our location. 

<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" 
	 p:prefix="/WEB-INF/jsps/" p:suffix=".jsp"></bean>

We can do 2 types of chaining

1. Basic chaining

addMinutes

return "forward:addMoreMinutes";

addMoreMinutes

Error: HTTP Status 404 - /FitnessTracker/addMoreMinutes

The link broke at the forward.  Since, it doesn't know what addMoreMinutes is. It should be addMoreMinutes.html

-> This goes outside the framework and comes back in.  It goes to web.xml <url-pattern>*.html</url-pattern>, so it looks for *.html. 

-> Now, it went in one method ourside our framework and came back in and hit that method again. 

MinutesController.java -> addMinutes() -> return "forward:addMoreminutes.html" --------------------> web.xml -------------------> addMoreMinutes()
																					went outside				came back and hit method

-> By including "forward:" in front of addMoreMinutes.html, it actually bypassed our view resolver that first time and went back though as a request and then went to our view resolver on this time. 

exercise: 14
adding exercise: 14

-> We can also do redirect 
return "redirect:addMoreMinutes.html";

exercise:14
addingExercise: 16

And the URL changes to 

http://localhost:8080/FitnessTracker/addMoreMinutes.html;jsessionid=A1479E3B08955152CC20B4BF8895C054

-> Becoz on the redirect, it had closed our request and created a new request. So we went through once with our original request, it finished that request and came in as another request and so it had lost its exercise information. 

uses of redirect:

1. websites where it is instructed as don't press back button as the credit card info can be charged twice -> redirect can stop this by stopping the backing up of info as it is already redirected. 
2. They'r actually a URL sitting ona different page on a different browser/ diff location which makes sure that they don't resubmit that page easily.

Static views
------------

-> there are methods in Spring MVC for displaying static data. 

static view -> pdfs/ images

<mvc:resources location="pdfs" mapping="/pdfs/**"/>

pdfs -> folder name
/pdfs/** -> ** means inside the foler pdfs look recursively

http://localhost:8080/FitnessTracker/pdfs/Divya_LIC_Receipt.pdf

pdf file is opened

-> This bypassed the controller and sets up a controller behind the scenes. 
-> It's a file resolver controller that just goes out and looks for files on our path and uses the location information in servlet-config.xml to find the file and serve it to back up for us without having to go through and confiigure a view resolver and set up a controller. 


Tags
=====

-> Tag libraries are used to make interacting with data easier in our pages. 
-> Spring MVC tag libraries are written on the java standard tag library specification and are included as part of the spring web jar. 
-> There aer 2 tag libraries in sPRING mvc, 

1. Spring.tld
2. Spring-form.tld

spring.tld -> The spring tag library provides some tags for evaluating errors, setting themes, and outputing internationalized messages. 

spring-form.tld -> The spring-form tag library is based around processing form data. 
				-> Most of the form tags are similar to html form tags but have binding for working with a backing object as well as validating  its data. 
 

spring.tld(image from desktop)

-> The spring tags are more about working with the application rather than processing information like the form tags are. 

hasBindErrors ->  used to see if we have returned errors from the controller or from our backing tier. 
url tag -> used to invoke a url and builds the path accordingly escaping characters that would normally break a request. 

-> some of these characters might be things like spaces or &. Things like that it needs to build into out URL for us. So these tags will effectively escape that for us in our application.

message tag -> used for externalizing strings out of the jsp pages

create a properties file, now maven work is to add anything in src/main/resources automatically to our class path. 

<spring:message

code is an attribute of spring:message, it is a key for the string that we want to pull out of message.properties file

code = goal.text

We need to create a bean for resource bundles to look up our resource bundles. 

<bean id="messageSource"></bean>

messageSource is referenced by spring message tags. 

p:basename="message" -> it ties to what we named our properties file

Interceptors
--------------

-> Interceptors are not part of the tag libraries but they are commonly used with tag libraries.

1. Registered and part of request life cycle -> involed with intercepting data that comes from jsp page and data that goes to controller.
2. Have the ability pre-handle and post-handle web requests. -> so they can intercept thinhs on the way to controller and vice versa.
3. Have callback methods that are used to override or change values.
4. Commonly used for Locale changing.

<bean>
</bean>

-> This bean is used when we want to intercept a request to change the locale that our web application is using for things like messages bundle.

<a href ="?language=en">English</a> 

when we click on the link, the URL is added with ?language=en

http://localhost:8080/FitnessTracker/addMinutes.html?language=en

Registering Interceptor:

<mvc:interceptors>
		<bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor" p:paramName="language"></bean>
</mvc:interceptors>

p:paramName="language" -> tied to language in the href link, this what intercepting

-> We had to register an interceptor and we had to set up a locale resolver so it would look and know where to look for what locale wh're currently using.

-> In the example, the interceptor is intercepting the language that we're passing thriough and binding that to our page.

Spring-form.tld(image from desktop)

-> form tags are all about working with html forms.
-> Their names a re similar to html options that they are meant to be representing.
-> The reason why we want to use these over standard html elements is that form tags are meant to bind to objects from our model as well as carry error information on required fills.
-> They also take a CSS class for changing their display from normal to error status. 
-> They're also javascriptive attributes and other things that we can tie to as well. 
-> Some of the events like on focus, on click, key press events.
-> They reduce the amount of code that we have on JSP pages.

Example: GoalController

-> Spring will pass in the backing model to the method addGoal and since it's passed by reference instead of passed by value, this is a pointer back to our actual object. 
-> It's not just go away at the end of the method becoz it's going to be absorbed back into the framework as part of the interceptor as part of the requestlifecycle.
-> So, the object(model) will be available to use and it will actually return data back to our jsp page for us.

@RequestMapping(value="/addGoal", method=RequestMethod.GET)

RequestMethod.GET -> This method handles http requests of GET so the http request GET is all that this method is goingt o handle. If we try to
					 post to it, it's actually going to error out.
				  -> Reason we want to add this is that, as we're setting up our page, we only want certain things to go this method.

http://localhost:8080/FitnessTracker/addGoal.html

-> We receive error after clicking submit button, 
Error: HTTP Status 405 - Request method 'POST' not supported

When we remove method=RequestMethod.GET, from the code and try to click submit, it's not doing anything becoz new Goal() is created every time.

-> If we want to store any info in our session, use @sessionAttributes annotation. We just tell it which attribute we want to store our session. 
-> In the example, it is "goal"
@SessionAttributes("goal")
-> The goal attribute ties to goal in the model.addAttribute
model.addAttribute("goal", new Goal());

-> We can check if the goal object is saved int he session by displaying it in jsp page.

<h1>Goal for the day is: ${goal.minutes}</h1>

-> It pulled that value out of the session and redisplayed it for us in that page. 

Summary: 
-> We redirected out of the page, addGoal.jsp, the first time we request it, it comes into our goalController and it returns us to addGoal which goes back and displays the addGoal.jsp page, binds us to the goal object (by unsing commandName="goal), we submit back up to that so we actually do a post back up to our controller and it will bund us to the goal object that we created. Once it's bound and it's updated everything, it redirects us back to addMinutes.html.

Validation
==========

-> Using tag libraries and the model object in SPring MVC, we can easily validate data passed to our controller in a potomatic way. 
-> 2 types of validation

1. Constraint validation
2. Business logic validation

Constraint validation

-> Constraint validation is when you are expecting a field like name not to be null/ password and re-enter password must match, those type of requirements.

Business logic validation

-> Business logic validation are what Spring MVC has built in mechanisms to help us validate againt. It should be handled in service tier, not the controller.
-> This type of validation is guarenteeing things like an entity is valid in the database or a username isn't already taken in our LDAP server/db.

Tags
----

-> All form tags have an error class for setting a specific color, font or combination of both for displaying errors.
-> There is a specific error tag for displaying validation errors.
<form:errors path="firstname"/>
-> In the above, errors tag is used to look at the path firstname, which is a member variable inside of the object that we bound to display errors that might have occured on firstname.

Validator Interface
-------------------

2 ways to handle validation in Spring MVC

1st way
-------

->  to use the validator interface and the validation utils helper class. This is used with simple form controller and don't deal with annotations much.

Validator class
---------------

-> implement the validator interface and implement all logic in the implementation of this interface.

validation utils Class
-----------------------

-> validation utils helper class helps us to look whether a field is empty or if it just contains white space.

Binding result class
---------------------

-> comparing password or email field to make sure that they've entered the email twice correctly, it can compare these types of things and it does this using the binding result class.
-> We can use it in service tier to do things outside of Spring MVC.

SimpleForm Controller
---------------------

-> Simple form controller, which is a kind of pre-annotation way of setting up controllers and it's kind of a narrow focus controller. 
-> The simple form controller is just dealing with forms and kind of a single post to that form. So, we can't do multiple things inside the controller. 
-> It is not commonly used anymore.

These validations are falling short now since new JSR specification is there for validation. 

JSR-303
=======

1. specification standard for validation ->  Java standard, not spring standard or a spring API.  
										 -> SPring MVC integrates with JSR-303 for its validation process and reporting errors. 
										 -> Good things is that we can use this in any application or across multiple tiers.
2. Annotation based -> can be extended to use our own custom validation rules we well
					-> can be used to build our own JSR-303 compliant rules and have those implemented inside of our actions as well.
3. Hibernate validator -> The reference and limitation is actualyl called Hibernate validation. 
					   -> the hibernate validator has nothing to do with Hibernate.
					   -> Hibernate validation started as part of ORM tool but they separated out to a completely, its own specification.
					   -> Other than the hibernate ORM tool we can use the JSR-303 defined objects and rules to validate code against back end, but nothing to do with hibernate.
4. POJO based -> Since it is annotation based that measn it works with POJO.
              -> no need of implementing interfaces or things that we have to bind to, to get these rules to be applied.
			  
Adding JSR-303 validation to out FitnessTracker application.

We need to add the Maven dependancy for hibernate validator in pom.xml

<dependency>
    	<groupId>org.hibernate</groupId>
    	<artifactId>hibernate-validator</artifactId>
    	<version>4.2.0.Final</version>
</dependency>

Below jars are imported in the Maven Dependencies

-> hibernate-validator-4.2.0.Final.jar
-> validation-api-1.0.0.GA.jar

-> validation-api is a transitive dependancym it's Java X validation so it is a Java specification.

@Range-> we can put a range on a field with min and max values in the POJO (Goal)

	@Range(min=1, max=120)
	private int Minutes;
	
	
@Valid -> used in Controller, it validates the model attribute 

BindingResult result -> the result object will contain response from validation off of @valid 
					 -> when the method gets called and it checks to see its valid, the result object will contain whether or not it is valid and has any errors.
					 result.hasErrors()
					 -> this performs validation with the range given ( i.e., min 1 and max 120)
					 
If number of minutes entered is negative, We can get result.hasErrors()= true, but what error can be found in jsp page. 

<form:errors path="*"></form:errors> -> * means we want all errors 

Summary: Goes through our object, adding a range and going in our controller and saying that's valid. We grab the binding result so that we can put some logic about where the page should go based on those errors. 

Ajax
====

-> Ajax and Restful services using Spring MVC.
-> Spring MVC has the ability to produce different content based on our request type.


REST
----

-> Restful services have taken SOA world by storm.
-> They are easy to work than SOAP and more consumable across applications. 
-> SInce they are built on top of the http specification and can produce JSON they are a great match for Javascript Mashups.
-> Spring MVC framework allows us to return JSON just as easily as html by simply using a different view resolver.
-> No need of using diff frameworks like jersey or axis or cxf  to expose a restful service. 
-> The rest services of Spring MVC are not as feature rich as Jersey but support most of the features that Jersey has and don't require a separate tool of framework.

Verbs
-----

1. CRUD

-> Restful services are all about what we can do against a domain object. 
-> The verbs or actions are the interface that we can interact with against this domain object. 
-> domain object means CRUD functions.
-> CRUD - Create, read, update and delete.  -> 4 functions we do against database.
-> REST is built with same notion.

2. POST

-> same as Create, we do post when we want to create an object through a RESTFUL service.
-> Post is used for both create and update.

3. GET

-> it is a synonymn with read.
-> Parameters can be passed on a URL or part of the path of the url. 

4. PUT

-> Put is supposed to be used with updates but is usually overridden and sent using a post instead.

5. DELETE

-> used for deleting


ContentNegotiatingViewResolver
------------------------------

1. Accepts XML, JSON, HTML

-> The ContentNegotiatingViewResolver is what makes it possible to return various content types from our application based on the request.
-> It uses the except header that is sent using http headers t determine the content that it will host up.
-> It can aslo look at the file extension that is sent as well.

2. Multiple View Resolvers

-> This can be cobined with other view reolvers, they just need to have an order that is associated with them.
-> We can return xml and JSON as part of the view order, as long as it's ordered before internal resource view resolver.

3. Additional jars needed for the Marshaller

-> for the various output types that we want within the application.
-> Jackson is used in the example to martial our data to JSON.

Example:

Add Maven dependency for ContentNegotiatingViewResolver

2 ways we can add:

1. adding in pom.xml -> source tab
2. adding in pom.xml -> dependency tab

<dependency>
	<groupId>org.codehaus.jackson</groupId>
	<artifactId>jackson-mapper-asl</artifactId>
	<version>1.4.1</version>
</dependency>

<dependency>
	<groupId>com.thoughtworks.xstream</groupId>
	<artifactId>xstream</artifactId>
	<version>1.3.1</version>
</dependency>

<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-oxm</artifactId>
	<version>3.2.0.RELEASE</version>
</dependency>

spring-oxm -> spring-object xml mapper, it is a tool that xtreme uses when it's marshaling stuff out of xml.

-> In the servlet-config.xml, Internal resources view resolver had to be the last view resolver that gets called. 


org.springframework.web.accept.PathExtensionContentNegotiationStrategy

-> This tells it which path types we're going to accept. 

Property - defaultViews -> it is basically what we want to use, what framework do we want to use based on the view type that's coming through so inside we have a list.

servlet-config.xml
------------------


<bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver">
	<property name="order" value ="1"></property>
	<property name="contentNegotiationManager">
		<bean class="org.springframework.web.accept.ContentNegotiationManager">
			<constructor-arg>
				<bean class="org.springframework.web.accept.PathExtensionContentNegotiationStrategy">
					<constructor-arg>
						<map>
							<entry key="json" value="application/json"/>
							<entry key="xml" value="application/xml"/>
							
						</map>
					</constructor-arg>
				</bean>
			</constructor-arg>
		</bean>
	</property>
	
	<property name="defaultViews">
		<list>
			<bean class="org.springframework.web.servlet.view.json.MappingJacksonJsonView" />
			<bean class="org.springframework.web.servlet.view.xml.MarshallingView">
				<constructor-arg>
					<bean class="org.springframework.oxm.xstream.XStreamMarshaller">
						<property name="autodetectAnnotations" value ="true" />
					</bean>
				</constructor-arg>
			</bean>
		</list>
		
	</property>
</bean>


-> The above configuration in servlet-config.xml, sets up to be able to handle those views based on JSON requests or xml requests and there's other types of requests which can be done.

@ResponseBody -> It says what you return is the actual content that I want to expose.


Web.xml
-------

1. The dispatcher servlet that needs to be configured to allow the various request types through. 
2. HTML -> We used, internal resource view resolver to look up our jsp pages. 
3. PDFs -> We used MVC resources
4. JSON -> We used content negotiating view resolver 
5. XML -> We used content negotiating view resolver, to allow xml content through.

-> Add things to servlet-mapping to let these other file types come through. 

http://localhost:8080/FitnessTracker/activities.json

-> [{"desc":"Run"}, {"desc":"Bike"}, {"desc":"Swim"}]

JQuery
------

-> Javascript framework with multiple plugins
-> Easily consume JSON, can create html on fly.
-> Download Jquery from http://docs.jquery.com/Downloading_jQuery
-> Jquery is just a file that we drop into our project so we don't download it using Maven.
minimilist version ( all white spaces condensed)



























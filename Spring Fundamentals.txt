												Spring Fundamentals
												===================
												
Spring topics
=============

1. XML configuration
2. XML configuration using annotations
3. Java Configuration.
4. Reading properties files using Spring framework.

Spring
======

1. JEE
------

-> Spring framework started out as just an inversion of control container. 
-> It was conceived to reduce or replace some of the complex configuration of earlier JEE development.
-> Spring later built around using Java without EJB's, so its original concept was how to work better with EJB's, and they are not needed in lot of situations.
-> Spring is a framework built around reducing the complexities around Enterprise Java development, later also providing enterprise development without EJBs.
-> Spring can be used with or without EJBs, typically no it is used without them. 
-> Spring enabled us to do enterprise development without using an application server. 
-> Tomcat isn't an application server, it's just a web sever. That is the reason Tomcat has taken over for the Java development standard container.
-> Tomcat is easy to use, lightweight. Before spring we either weren't using enterprise features, or we had to use more complex, harder to use application servers.

2. POJO Based
-------------

-> Spring is POJO based. ( Plain Old Java Object)
-> Any code we write in spring can be written without spring. 
-> Spring helps us in writing better, cleaner code, and doing things POJO-based and interface driven.

3. Unobtrusive
--------------

-> Spring was built out of frustation of J2EE, so its unobtrusive.(attract attention)

4. AOP/proxies
--------------

-> Spring also uses AOP and proxies to apply things like trasactions to our code, to get the cross cutting concerns out of our code.
-> So, the code should actually be smaller and more lightweight from using spring.

5. Best practices
-----------------

-> The appealing part of spring is its best practices. We usually have design paterns in our code, not realizing that we are using them. Things like singletons, factories, abstract factories, all those best practices are built into our code inherintly, just using spring. 
-> Spring uses the template method pattern a lot, its a more degin based methodology, that's annotation based configuration.

The problem
===========

Whenever we are going to introduce another framework or tool into the code base,  what is this trying to solve for us?

Spring brings below things

1. Testability 
2. Maintainability
3. Scalability
4. Complexity

-> All the above are properties of our code, it decouples things and makes it so that we can add things like caching and other tools without having to rewrite our code base.

Business Focus
-------------

-> There would only be 2 lines which are focused by business in the JDBC code, (select stmt and storing result) but we need to write lot of code for connections and other stuff fro closing connections. 
-> Spring will be handling all this for us. 

Solution
========

1. We can remove configuration code, or lookup code, 
2. we can focus on business needs. 
3. Focus on testing
4. Spring helps in doing annotation or XML based development. 


Below library in spring is enabling us to condense the JDBC code, we don't need any connections or result sets or prepared statements. This is an example of template method and spring uses it a lot to help us clean our code. 

public Car findCar(String id){
	return getEntiryManager().find(Car.class, id);
}

How it works
============

-> Everything in spring is simple POJO. Spring can be thought of as a glorified HashMap.
-> Spring is creating hashmap and shoving objects in there.
-> Spring can also be used as a registry, we get benefits from spring by its wiring constructs and using auto-wiring. 
-> Inside the spring container there are beans and references to them. Some of them are standalone, some of them are referencing other beans. 
-> If we take the JDBC example, the beans and references may be the connections, prepared statements and entity manager. 
-> So, all the beans get stored in the little container and then we access them out of the container. That's where the Hashmap comes into play. 

Architechture and basic project setup
======================================

Why spring was developed in this way?

-> Spring was developed to make existing tasks easier.
-> Before spring, we used design patterns from the JEE blueprints to help establish better code and repeatable processes. 
-> These blue prints helped to establish a consistent way of dong things, but often still made code brittle and untestable. 
-> If we ever need to recompile the code, becoz of the environment then we get through these problems. 
-> This problem is referred to as "Write Once run everywhere"(WORA)
-> We need actual implementation instead of hard coded values. This is what spring help us with. 

Java 8
Spring 4
Maven
Eclipse / STS - Spring Tool Suite -> It has some of the common plugins already installed. 
Tomcat

spring_sample project(maven project)
=====================

pom.xml
------

Java compiler dependancy




-> The default constructore in the class is used by the spring, and we are not doing any constructor injection. 
-> We created stub rather than hibernate repository, becoz we're not goint ot wire it, clear up, to hibernate in the example.
-> this is a basic stub.method. But to use this inside of spring, we need to code this to interface. So, we need to extract interface out.
There are 2 ways 

1. Right click on class -> new interface -> write down code
2. Extract interface out.
	Right click on application -> click on Refactor -> click on Extract Interface -> provide interface name and methods to include -> OK
	
-> when we refer stub.method, we can now do it through the extracted interface. 

source tire -> business logic resides

-> Spring removes the hardcoded objects. 
-> Spring is all about removing configuration code from your application. 
-> Configuration code is a bad thing becoz it makes things brittle i.e., hard to move to different environments. 
-> recompiling code when we need deploy the code in different environment, testing matters. It becomes hard since the configuration is hard. 
-> It may have reference to JNDI or some other database. 
-> Wherever we see creating interfaces, and it's tied to a concrete implementation, we should try and abstract that out of out code. So that our application isn't hardcoded anymore. 

Getting Spring
==============

-> No direct download for the compiled jars. 
-> Spring wants us to download tools using Maven.
-> Maven repo has source, javadocs, binaries.
-> Spring insists Maven becoz of dependencies which are required to run projects. As which jar to use.
-> Spring Boot can be used to set up our application, but it is like black box. 

Spring Dependancy

browser -> spring.io -> projects -> SPring Framework 

<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>4.3.5.RELEASE</version>
    </dependency>
</dependencies>

Spring XML Configuration
-------------------------

-> XML configuration was the first method available in spring. 
-> Some things are still simpler using XML.
-> There is separation of concerns that organically happens when configuration code is removed


applicationContext.xml

-> XML configuration in spring begins with a file i.e., applicationContext.xml
-> It really is the root of the application configured using Spring and XML. 
-> It doesn't have to be named as applicationcontext.xml. Name doesn't matter.
-> It should be an XML file.
-> If we use applicationContext.xml, Spring will do things using convention over configuration by default to find and discover pieces of our application on its own.
-> Spring is just a HashMap of objects and we define that HashMap inside of our applicationContext.
-> The objects that we have inside of here are like name, value pairs.
-> This can also be used as a simple registry and we look up those beans that we define in that HashMap out of this applicationContext file. 
-> XML configuration begins with this file.
-> We can have other files that this will reference and lookup and pullin. 
-> There are some namespaces that spring developers have put together that help usin our configuration and validation of files.
-> Basically, we put an XML snippet at the the top of our applicationContext and it knows what our bean's namespace is to help us configure the rest of our file. 

Spring Tool suite -> Get from Eclipse Market Place -> Install -> Open Perspective.
-> src -> Right click -> new Spring Bean configuration file -> Name it as applicationContext.xml

-> xml namespace is the default namespace  of beans
-> xsi is XML schema instance. 
-> The schemaLocation is added to the xml file gives the context sensitive help inside of our application.
-> We get contexts like bean, beans, description in the xml. We get those by adding the namespaces in XMl.
-> This helps to define wellformed and valid XML. Valid in the sense we can out the element in the location in XML.
-> Ex: bean tag in XML, it throws no errors as we have added namespace.
-> Ex: context tag if used in xml will throw warning saying that it doesn't know what this is at this location. It says it is well formed, but it is not valid XML.
->  STS will be adding all namespaces for us, without it we should be writing all manually by creating normal XML.
-> Creating a normal XML file will not save it as a spring configuration file. But, the by creating with the spring bean configuration file, it creates all other required tabs inside the appplicationContaxt.xml file like beans, bean graph becoz the ID has registered this as a spring configuration file. 
-> By using STS, it gives lot more features.

Bean namespace
---------------

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	
-> Spring created this namespace that simply acts like a dictionary for the properties that we can use to create and inject into a bean. 

XML declaration
---------------

<bean 
	name = "customerService"
	.............
	<property ........
</bean>

-> This bean is the customer service bean that represents where we wnat to put our business logic inside of our applciation. 
-> The XML configuration is composed of beans and beans are basically classes. They're just pojos that we use inside of our applicationContext.
-> Defining beans can be thought of as replacing the keyword new. 
-> Ex: CustomerService x = new CustomerServiceImpl(); 
   We can remove this configuration and place it into an XML file.
-> We define the class and use the interface. (shown in demo)

Separation of concerns
-----------------------

-> We can now change the configurations without recompiling the code. We can switch from environments like dev to test and we just use a different configuration file and do not have to recompile pieces of our applciation. This technique is called, separation of concerns.

-> Inside bean tag, we can use name and slo property ID instead of name. Id has to be valid XML, so we can't use some characters that might want to inside of our name. 
-> class inside bean tag. Out file inside of our file we want to use the implementation but reference the interface. So, as we are defining the bean we use the actual implementation of it as our class. 

Setter Injection
----------------

-> After defining a bean, we cna use the bean using injection. 
-> There are 2 types of injection.
1. Setter Injection -> getters and setters of the bean.
2. Constructor Injection -> uses the defined constructors.

-> We can use both types of injections together. 

Setter Injection 

Customer ref = new customerImpl();
 remove the new customerImpl() in the file, and create the setther for the ref.
 
-> property tag inside the bean will wire another bean together by name and we can pass a ref of another bean.
<property name = "customerRepository" ref = "customerRepository"/>
-> Thus we done setter Injection wired by name. 


ApplicationContext appContext = new ClassPathXmlApplicationContext("applicationContext.xml");

-> This will look on our Class path for us and find our applicationContext.xml file. 
-> Maven automatically places that file in the right place. 
src/main/resources -> applicationContext.xml
-> Maven will compile that into our application at the root of our application.
-> So, in our classes directory applicationContext.xml will be copied at the toot of that directory structure. So, we don't have to put any path information. 

CustomerService service = appContext.getBean("CustomerService", CustomerService.class);

-> appContext can be used to find the bean. We are using interface instead of concrete class so that we can swap out the implementations behind the scenes without having to recomiple our application. 
-> getBean(String T, class<T> arg) , we are passing the class type also since it would remove the typecasting. 

3 ways we can read an spring config XML file(Interfaces)
1. BeanFactory 
2. ApplicationContext
3. WebApplicationContext

Implementation classes for above

1. BeanFactory ref1 = new XMLBeanFactory(new FileSystemResource("full file path"));
   BeanFactory ref2 = new XMLBeanFactory(new ClassPathResource("filename")); -> file should be in class path.
   
2. ApplicationContext ref1 = new ClassPathXmlApplicationContext("filename"); -> file     should be in class path.
   ApplicationContext ref1 = new FileSystemXMLApplicationContext("full file path");
   
3. WebApplicationContext ref1 = new XMLWebApplicationContext("xml file"); 
-> XML file should be in WEB-INF, the name should be according to the servlet-name tag entry in web.xml.
Ex: <servlet-name> myspring</servlet-name>
xml file = myspring-servlet.xml
-> Used only in Spring MVC.

Diff between BeanFactory and ApplicationContext
-----------------------------------------------

-> BeanFactory lightweight. ApplicationContext heavy weight.
-> ApplicationContext supports I18N ( internationalization) while BeanFactory doesn't.
-> ApplicationContext can publish events to beans which are registered as listeners, while BeanFactory doesn't support event handling.
-> In BeanFactory objects are lazy, while in ApplicationContext objects are not lazy( the objects are created when applicationContext reads the xml file) 

Lazy loading - the objects are created when we call a method on the object or on the use of the object

Constrcutor Injection
---------------------

-> We have defined contract when we create object. 
-> A positive and a negative though is that we need to have a constructor defined for each situation. 
-> Constructor Injection is index based and not named-based, like setter injection is. 

<constructor-arg index = "0" ref="customerRepository"/>

public CustomerServiceImpl(CustomerRepository customerRepository){
		this.customerRepository = customerRepository; 
	}

-> index is the argument position.
Ex: If we have 3 arguments to pass in, then we start with index at position 0, position 1, position 2 and pass those objects into that constructor. 
-> By Constructor Injection we can know that things initialized the right way. 

We can use both setter and Constructor injection as below

<bean name="customerService" 
		class="com.spring.service.CustomerServiceImpl">
		<constructor-arg index = "0" ref="customerRepository"/>
		<property name="customer" ref="customer"/>
	</bean>

   
Autowire
========

-> Earlier, drawback of spring was having lot of XML configuration. We need to wire up every bean and all the references and everything that went into it. 
-> To counter this, spring introduced autowiring, for us to autowire beans together. 
-> There are 4 types of autowiring that we can do on a bean. 

1. by type 
--------------

-> allows a property to be autowired if exactly one bean of that property type exists withing the container.
Ex: CustomerRepository is bean of specific type, I we had 2 beans of same class but with different names, we would get an exception using this approach becoz, it couldn't tell which bean to choose. 
-> it will look at the arguments for the setter. Ex: type of object is customerRepository. 
-> it doesn't care of the name of the bean and name of the setter. 

2. by name
-----------

-> By name fixes the problem of by type.
-> Both are good, becoz by type will allo us to only create 1 instance of that class in our container in our applicationContext.
-> by name, will allow us to have multiples and choose that specific object based on the name. 
-> by name looks for the setter of the bean. Ex: customerRepository bean, it checks for setCustomerRepository. If we change the name of customerRepository then it would through exception.
-> setter injection

3. by Constructor
-----------------

-> Constrcutor auto-wiring is similar to setter injection by type. 
-> It looks for an object of that type to inject into the arguments of the constructor. 

4. no/ none for autowiring
-----------------------------

-> Cannot be autowired at all. 


5. default
------------

-> default = no autowiring


-> "property" and "constructor-arg" elements, always override autowiring

Annotation configuration using XML
==================================

-> Annotation configuration is the second method available in spring to wire up our application. Most of the configuration done in spring is using annotations. 
-> We need a place to bootstrap the annotation scanner, and we do that in a applicationContext.xml.
-> The difference is that we just have an annotation scanner in there, and that goes out and looks for specific items. 
-> So we'll have our configuration to bootstrap an annotation scanner, and then it uses the same conventions as the XML configuration. 

XML declaration
----------------

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context.xsd">

-> To start up the component scanner, we need to add 2 things to our application context
1. context namespace
 -> It has schema defining context and the xsd location. 
 -> Just like beans specification we can add the context specification and schema to the top of our document. 
 -> We need to add 2 elements to our schema. 
 -> We need to tell our application that it is configured using annotations, and then where to start scanning for those annotations. 
 --> First element says " it is configured with annotations"
 -> second element says " this is the package that it sould start looking for these annotations in."
 -> We can drill down to a specific package, and tell it to only load things from that specific location. 
 -> Adding annotation, configuration and location scanner is easy inside of our application context. 
 
 applicationContext.xml file -> in the bottom tabs select Namespaces -> Select "context" namespace. and then version as spring-context.xsd
 
 -> spring-conext.xsd is choosen non version specific, since it wwould be independant of the spring version. 
 -> In the xml file, context URi and context xsd are added to our application. 


Sterotype annotations
=====================

-> There are 3 main annotations for core spring that help us to find components, or beans, inside of our application. These are called as stereotype annotations.
1. @component
2. @service 
3. @Repository

-> They are semantically the same. Service and repository both extend component, but really don't add any features or functionality.
-> Component is used for regular components or beans/ any POJO.
-> So, anything in our application we want to be a bean, we mark with a component.
-> Service is where our business logic contains. 
-> In Spring MVC, we don't put business logic in controllers but we put them in service tier, or a business logic layer, and mark that with @service.
-> Repository is our data access tier, or DAL layer. It is where we do our interaction with database. 
-> Spring JDBC/ hibernate/ iBATIS that tier is labeled with @Repository.

Ex: @Repository("customerRepository") -> making it as a repository bean 

Autowire in annotations
-----------------------

-> Autowiring a method is hidden because it's tied to where we place that annotation at.
-> We can autowire in 3 places
1. Member variables
2. Constructor
3. Setter Injection

Autowired Memeber variable

@AutoWired
private CustomerRepository customerRepository;

-> Using component scanner, spring will look for any code marked with the stereotype annotations, and the autowired annotations, and wire up the application properly.

Autowired setter injection
==========================

private CustomerRepository customerRepository;
	
@Autowired
public void setCustomerRepository(CustomerRepository customerRepository) {
	System.out.println("using setter Injection");
	this.customerRepository = customerRepository;
}

-> We generate setter and then just place an annotation at our method as above.

-> Like memeber variable autowiring, spring using the component scanner looks for any code marked with the stereotype annotations and the autowired annotations and wire up our application appropriately. 

Autowired Constructor Injection
===============================

-> It is similar lo setter approach. 
-> We create a constructor for the type of object that we want to inject in, and then simply mark that constructor as autowired. 
-> If we switch back to setter or member injection, becoz we have eliminated our default constructor.












									Spring with JPA and Hibernate
									=============================
									
What is JPA?
------------
-> JPA - Java Persistence API, focused on Object Relational Mapping - ORM.
-> Originally JPA was part of EJB, but later available on its own.
-> Started as Hibernate and then extracted a standard interface.
-> It is ORM tool - how we map Object Oriented language Java to our replational database.
-> It is POJO based. JPA focuses on good object oriented design.
	1. XML configuration
	2. Annotation based configuration.
-> Built around patterns and best practices 
	1. Helps keep our code OO.
	2. Pluggable persistence providers
		- Hibernate
		- Toplink (before Java, developed by Smalltalk developers)
		- EclipseLink
		- OpenJPA
		
History of JPA
--------------

Hibernate 1.0 -> 2001 by Gavin King 
JDO 1.0 -> 2002 - focused on storing more than just relational databases like XML or flat files.
JPA 1.0 -> 2006 - Entity beans are heavy weight and complicated, they had to be used on application server instead of a 
			      lightweight Tomcat. Many third party features are included in JPA. Hibernate and TopLink became implementations of JPA.
JPA 2.0 -> 2009 - address features that weren't present in popular ORM vendors
Hibernate 3.0 -> 2010 -annotation based and is an implementation of JPA 2.0 specification.

-> Now, JBOSS acquired Hibernate, open source implementation, can be used on any container, doesn't have to be used with JBoss.

Problem
--------

Why we need to use HIbernate or JPA?

-> Developers don't always make good DBA's. - like not understanding foreign key constraints or how to best represent what they are trying to do in a relational database.
-> Data model doesn't line up with Object model.
-> Configuration is better with JPA, but still could be better..
	1. Transactions 
	2. Testing
	3. Datasource configuration
	
	Thease are solved by Spring and JPA.
	
-> Business focus
	Ex: we may have 40 lines of code using JDBC to retrieve details of car based on Id and assignining it to an object, but business focus is only 2 lines. There is finally block which closes connections, if not we run out of connections, out of memory or heapspace or permgen.
	
	
The Solution
------------

-> JPA removes boiler plate code.
-> Helps deveolopers to build objects and JPA bridges the gap between relational database and OO code.
-> Spring handles the configuration and transactions.
-> Code can focus on testing.
-> Transactions are transparent to the developer.
-> Annotation based development.

Business focus 

The huge JDBC code turns into below code, 

public Car find(Integer p){
	Car car = getEntiryManager().find(Car.class, p);
	
	return car;
}

Scaffold application
====================

Application build in SPring MVC course.

Prerequisites
-------------

1. Java 7 or greater
2. Maven 3.x or greater
3. Spring STS
4. Tomcat 7 or greater

Requirement:

Everytime we post to the fitnessTracker page, it just throws away the minutes added at the end of that request response life cycle. We need to flush out the rest of the way using JPA and Hibernate and Spring to configure JPA and Hibernate.

-> Bootstrap and Jetstrap were included in the downloaded application by Hansen.

persistence.xml
---------------

JPA without spring, we specify

1. datasource
2. allowed operations
3. caching

why spring?

-> Can override settings per environment
-> easier to test
-> inject into other resources

Using spring also we need empty persistence.xml file
-> src/main/resouces/META-INF/persistence.xml

Maven will keep implicitly find places anything inside te META-INF directory

persistence.xml

<persistence xmlnamespace="http://java.sun.com/xml/ns/persistence"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence_2_0.xsd"
	version="3.0">
	
	<persstence-unit name="punit">
		
	</persstence-unit>
	
</persistence>


web.xml
-------

-> for JPA we use 

1. listener inside web.xml
2. context-param
	-> name - contextConfigLocation
	-> value - classpath:/jpaContext.xml

classpath:/jpaContext.xml -> tells where on classpath to find this value, it will be at the root.

<listener>
	<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>

-> When our application starts up, the listener class is actually triggered by the container to start up the above listener. 
-> Then this looks for a context parmeter named contextConfigLocation, which in turn looks for classpath for a file named jpaContext.xml

jpaContext.xml
--------------

-> used in place of the persistence.xml
-> so all those we place inside jpaContext.xml are loaded by spring
-> jpaContext.xml ( just a standard naming convention)
-> Loaded from classpath, configured in web.xml using context loader listener.
-> Once loaded, place it in src/main/resources/jpaContext.xml
-> Contains:
	1. EntityManagerFactory
		-> JPA vendor
		-> JPA Properties
		
	2. Transaction Manager
	3. Annotation Configuration
	4. Datasource configuration or lookup


src/main/resources/ -> New -> spring bean configuration file -> jpaContext.xml

Under namespaces tab, check the context and tx

<context:annotation-config/> -> tells spring that configure rest of the application usign annotation. scan classpath and items inside the context file, inject into other beans that we have created.

bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/> -> tells spring to use the persistent context annotation.

EntityManagerFactory
--------------------

-> used to start up JPA and Hibernate inside of the application.
-> CLass "LocalContainerEntityManagerFactoryBean" is present inside that,
	1. located inside spring-orm.jar
	2. references our persistence unit.
	3. Injected datasource if one isn't defined in the persistence unit.
	4. defines what vendor(JPA provider) we are using.
	5. options to specify vendor specific JPA properties.


Transaction Manager
------------------
















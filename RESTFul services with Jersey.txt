									RESTFul services using Jersey
									=============================
									
What is Jersey?

-> Jersey is an implementation of the JAX-RS specification.
-> It is Java's implementation of REST. 
-> It is used to create and consume web services according to the representational state transefer, or REST Architectural pattern. 
-> Jersey is one of the implementation, it is default and it should run on any J2EE compliant container.

Topics:

1. Build first application
2. Architecture
3. JSON/XML
4. CRUD functions
5. Client code
6. Error handling


-> Jersey lacking point is its security model. Only basic autthentication s provided. We can run REST over SSL which guarentees that the integrity of our data doesn't get compromised.

REST Overview
-------------

-> REST was built with the pains of SOAP.
-> REST was built on top of the principles of HTTP(POST, GET, PUT, DELTE)
-> Services can return formats like XML, JSON, HTML, simple plain text, and binary octect(images/pdfs).

RESTFul URLs
------------

1. Always centered around nouns but never centered around verbs.
	-> We have concreate objects which say what the URL is.
	-> Ex: http://localhost:8080/car-rental/cars this means that we want to retreive all cars in the car-rental application.
	
2. The last element in the URl, i.e., cars in the above example are nouns.
3. Verbs are expressed through the protocol
	-> PUT
	-> POST
	-> GET
	-> DELETE
	
4. Path is used to get a specific instance
	-> Ex: http://localhost:8080/car-rental/reservations/1334 -> specific instance/ reservation

Build first application
=======================
	
Prerequisites
-------------

1. Java 7
2. Maven (download Jersey through Maven)
3. Spring STS/ Eclipse
4. Tomcat

What are we building
----------------------

-> Building services for an exercise application.
-> Goal of the application is to track minutes exercised in a day. 

Service features
----------------

1. Retrieve all activities that user has done.
2. Retrieve a specific activity.
3. Create a new activity
4. update a new activity
5. delete an activity

Tomcat
-------

-> RESTFul services are ran out of a basic war file.
-> Tomcat is a very lightweight web container.


Downloading Jersey
------------------

-> As recommended on Jersey's website, we are going to use Maven.
-> Jersey has an archetype to hep start things. 
Archetype - It is just a preset of files that are put together in a structure that makes sense for us, and usually some boilerplate code that's eleimnated for us. It's got dependecnies we need included in our project already configured and a basic folder structure setup for us.

Type below Archetype on the Maven command line and it will go through  and download our resounces and help us setup our project. 

mvn archetype:generate -DarchetypeGroupId=org.glassfish.jersey.archetypes -DarchetypeArtifactId=jersey-quickstart-webapp -DarchetypeVersion=2.25.1

-> First time we run this, it will pull all the resources that it has, it needs, and it verifies our local repository against the central repository.

It will ask for

groupId: com.rest
artifactId: exercise-services
version: 1.0-SNAPSHOT (default)
Package: com.rest

press Y -> Build successful


-> Import the existing maven project in SPring STS

Project Layout
--------------

1. Standard Maven structure
	-> src/main/java - Java code
	-> src/main/reources - property file/ xml 
	-> src/main/webapp - web.xml, WEB-INF folder
	
2. Libraries are pulled in throug Maven in the dependencies section. (pom file has dependency section that lists what we are pulling)

3. web.xml is already configured with Jersey servlet.

web.xml configuration
---------------------

-> Using the Maven archetype, it sets up our web.xml for us.
-> web.xml is present in src/main/webapp/WEB-INF directory and it contains the servlet configuration named as Jersey web Application


 <servlet>
	<servlet-name>Jersey Web Application</servlet-name>
	<servlet-class>org.glassfish.jersey.servlet.ServletContainer</servlet-class>
	<init-param>
		<param-name>jersey.config.server.provider.packages</param-name>
		<param-value>com.rest</param-value>
	</init-param>
	<load-on-startup>1</load-on-startup>
</servlet>

-> Jersey needs to be bootstrapped, or started up and this is how we do it.
-> It creates an instance of this class as the Server starts up.

<param-value>com.rest</param-value> -> This is where our servlet will start looking for our classes that are marked as RETFul services. So, we are annotating things, it goes through as says which directory should be looked ?, param-value tells that it the package to start looking in, com.rest.

-> We have a servlet mapping called Jersey Web application that maps to our servlet, and its URL pattern is webapi, which means anything with webapi in our URL is going to get directed to this servlet.
-> We can change this if we want to, but by default this is what they've set for us.

<servlet-mapping>
	<servlet-name>Jersey Web Application</servlet-name>
	<url-pattern>/webapi/*</url-pattern>
</servlet-mapping>

<web-app version="2.5" -> the version should be 2.5 or greater. 

Creating a service
------------------

->  The most basic service needs 3 things
	1. @path - the path to access our service
	2. @GET - the request method ( we use HTTP method GET)
	3. @Produces - the response type from the service (need to know what type of data it produces)
	
Ex: @Path("myresource")
	public class MyResource {
		
		@GET
		@Produces(MediaType.TEXT_PLAIN)
		public String getInt(){
			return "Got it";
		}
	}

-> In the project, under src/main/java -> com.rest package is created by Archetype and under that MyResource.java service is also created by Archetype. The above code snippet is present in that file.
-> It produces plain text.

Now add our application to tomcat server, start server and in the console we can see that it initialized Jersey application.

http://localhost:8080/exercise-services/webapi/myresource 

output: Got it!

We created a RESTFul service, the URL is tied to an object(myresource), we have path to it, and it produces a GET from it. The return type was plain text, 
In the output plage -> Rght click -> view page source -> it is plain text, there is no html


RESTFul Architecture
====================

-> REST is not an adhoc web service development. It's not a means of just throwing whatever service we want to get the job done.
-> There are some standards to develop RESTFul services.
-> Roy Fielding found REST, HTTP specification is the backbone of RESTful services.

Richardson Maturity Model
-------------------------


4 levels of Maturity - focusing on level2

Level 0: The swamp of POX 

-> sending plain old XML
-> focused on 1 endpoint.

Level 1 : Resources

-> Services are spread across multiple endpoints, and URLs and are more REST like, focusing on objects.

Level 2: HTTP verbs

-> This is considered as fully REST.
-> Services are focused around HTTP verbs. 
-> Ex: GET request method is used to get resources, POST method for creating resources.
-> Level 2, we use HTTP response codes.

Level 3 : Hypermedia Controls

-> adds links, hypermedia controls as what to do with return information. 
-> This is also referred to as HATEOAS.

We use level2, since Level 3 is still nonstandard between libraries, and not supported by all clients.

-> Level 2 focuses on HTTP verbs, so GET, POST, PUT, DELETE headers can be passed along with our request.
-> Create, Read, Update and Delete are the CRUD functions.
-> Web doesn't use Put and Delete.
-> Level 3 includes level2, but puts a focus on Discoverability.
	HATEOS - Hypertext As the Engine Of Application State
	
HATEOS
------

HATEOS - Hypermedia as the Engine of Application State.

-> We are going to supply a mechanism for the client to interact with the server through Hypermedia. 
-> The concept is to decouple the clinet and server, allowing them to evolve.
	-> Interaction begins with a fixed URL
	-> Future interactions are determined by server returning stuff based upon what we've requested.
	-> If we request a list of activities, upn those lists of activities that we're going to get returned are a set of links for what we can do with that activity.
-> THe concepts of HATEOAS are to help promote long term design
	-> Cam make short term design/productivity more difficult.
	
	
CRUD functions
--------------

-> CRUD functions are synonymous with modifying information in the database world.
-> Create, Read, Update and Delete
-> Level 2 of RMM is about matching services with their HTTP verbs, and the CRUD fucntions are mapped to their HTTP equivalents. 
	Create = POST
	Read = GET
	Update = PUT
	Delete = DELETE
-> Often people will use POST for Create and update

JSON
----

-> JSON stands for JavascriptObject Notation.
-> Preferred when working with Javascript clients
-> Looser way to represent data.
-> Flexible and easy to work with.
-> Common reason of using JSON is becoz it is not XML.
-> Difficult to validate.

To use JSON, annotate the method as below

@Produces(MediaType.APPLICATION_JSON)

XML
---

-> XML often gets associated with SOAP.
-> Still a great solution for REST.
-> REST doesn't mean unstructures, or unformatted.
-> Easy to validate and easy to confirm that it's well formed.
-> To use XML, annotate method with below

@Produces(MediaType.APPLCIATION_XML)

Binary
------

-> Not necessarily an alternative to JSON or XML.
-> Used to serve objects. It soesn't mean we expose Java object, but rather server up file/image/PDF.
-> SO, binary things serve up statically, or things that are stored.
-> If we have images in a blob in the database, or some pdf files, we use the binary octect stream to stream those out to the client.
-> To use it annotate the method as below:

@Produces(MediaType.APPLICATION_OCTET_STREAM)

Using HTTP GET
==============

GET
---

-> The GET method is used to retrieve records or get them.
-> It is associated with the Read function of our basic CRUD functions.

myresource
----------

@Path("myresource")
public class MyResource {
	
	@GET
	@Produces(MediaType.TEXT_PLAIN)
	public String getInt(){
		return "Got it";
	}
}

-> Annotated with @GET
-> Mapping is defined with @Path
-> URL is defined through our context/ servlet mapping/ @Path
-> Content retuned is defined with @Produces
	-> @Produces can take Array of multiple types of content that it can produce.(plain text, html, binary, XML, JSON)

http://localhost:8080/exercise-services/webapi/myresource

webapi is present in the web.xml, That's where we tell is that we want to direct all traffic to our Jersey application, and the path to our resource is defined by webapi/myresources, that's where path annotation comes. 

Activity Resource
-----------------

Create service to retrieve all of our exercise activities in the application. 

1. Create Activity class.
2. Create ActivityRepository.(DAO) (we stub out and make a fake database in the application.)
3. Create ActivityResource -> actual service, 
	-> Annotate with GET
	
We access our activities by calling below URL and retrieve all the activities that are available in the system.

http://localhost:8080/exercise-services/webapi/activities

com.rest.repository package -> referred to as DAO tier. Standard way of doing things, called repository, becoz it's more than a database repository, we can create repositories to interface LDAP or web services. So repository is a looser term than DAO.

ActivityResourceStub -> We want to stub out of database. We are not hooking this up t a database, we just return boilerplate code that would mimic a database. So, a common term for this is stub.

Exception:
----------

MediaWriter error -> common mistake using Jersey, how to tell out the media that we're dealing with.

MessageBodyWriter not found for media type=application/xml

Solution:
-------

@XmlRootElement -> place this annotation on the object, i.e., Activity object

-> This says that 'I am an element that you can expose, go ahead and display me".

Output:

<activities>
	<activity>
		<description>Walking</description>
		<duration>85</duration>
	</activity>
	<activity>
		<description>Cycling</description>
		<duration>20</duration>
	</activity>
</activities>

@XmlRootElement
----------------

-> Only for XML 
MessageBodyWriter not found for media type=application/xml
-> Jersey doesn't know how to marshal POJOs to XML.
	1. Need to define what the XmlRootElement is.
	2. can also rename other elements
		-> @XmlElement  - tie that to things like our description or duration.
	3. Can specify attributes too.
-> Uses JAXB to do Java-to-XML - to take that POJO to XML it is using JAXB, any element or annotation or feature that's available through JAXB can be accesses inside of Jersey. 


@XmlRootElement with JSON
--------------------------

@Produces(MediaType.APPLICATION_JSON)

Error : MessageBodyWriter not found for media type=application/json

JSON
----

-> Receives below error message MessageBodyWriter not found for media type=application/json
-> JSON requires another jar to be added to pom.xml 
	-> jersey-media-moxy - if we are using Maven and their Archetype.
-> @Produces(MediaType.APPLICATION_JSON)
-> Jersey uses JAXB and it converts POJO to XML and then XML to JSON. Even though we are asking for JSON, our object is going to get converted to XML, and then get converted to JSON. 
	-> Our XML annotations affect our JSON output
	-> description attribute converted to desc, using @XmlElement

To fix the error, MessageBodyWriter not found for media type=application/json, need to uncomment below dependency in the pom.xml.
<dependency>
	<groupId>org.glassfish.jersey.media</groupId>
	<artifactId>jersey-media-moxy</artifactId>
</dependency>

Output: 

[{"desc":"Walking","duration":85},{"desc":"Cycling","duration":20}]

-> Our XML annotation affected the output of our strings(description to desc) and that is because that under the hood they are taking and converting that to XML, and then XML to JSOn.
-> Other tools like Jackson, Restlets also do the same.

@Produces
---------

If we want to produce both XML and JSON?

-> @Produces annotation will allow us to produce multiple output formats.
-> @Produces can take a single String or and Array of Strings.
	-> To do that, define as below
	
	@Produces({MediaType.APPLICATION_JSON, MediaType.APPLCIATION_XML})
	
-> This may cause a problem, we need to use something besides our browser to set an accept header of what we want to see.
	-> Most browsers support some type of posting tool like plugins.
	-> They have standard tools that allow us to set our accept headers.
		Chrome - Postman
		Firefox - Poster
		
Add the Postman extension to chrome and provide the request URL, we can give the headers for JSON or XML 

Accept - application/json
Accept - application/xml

Specific Objects
-----------------

1. How do we retrieve a specific object, In the example we want to retrieve specific activity. 

	-> Provide the activity Id, at the end of the request URL.
		http://localhost:8080/exercise-services/webapi/activities/1234
	-> Use @PathParam to grab URL params.
		@PathParam("paramname")
	-> Can nest @Path references
		So, our Path on our class before that was of activities, would now be looking for activities/ and our ID.
	
2. This applies to nested objects as well, if we want to go though and retrieve a user object based on our Actvity, we can now build our URL to access Actvity/activityId/ the user object, and this will pull back just that specific user object for us.
	http://localhost:8080/exercise-services/webapi/activities/1234/user
	
Ex: Demo to add a specific activity. 

	
@Path("{activitId}") -> We need to give curly brace, becoz we are appending this to @Path("activities")

@PathParam ("activityId") String activityId -> This is how we grab a parameter from URL or qyery String. This is taking the 	activityId("activityId"), pull it from URL and store it in the activityId(String activityId)

-> Usually end user shouldn't see the id, http://localhost:8080/exercise-services/webapi/activities/1234

Output:

<activity>
	<desc>Walking</desc>
	<duration>85</duration>
	<id>1234</id>
</activity>


Ex: User Demo

@Path("{activitId}/user") // http://localhost:8080/exercise-services/webapi/activities/1234/user 

This will retrieve a specific user that's inside of our activity.

http://localhost:8080/exercise-services/webapi/activities/1234/user

Browser Output:

{"id":"5678","name":"Gayathri"}

We got json, instead of XML, because the default xml failed. so it returned Json format. Everytime we should be checking the output in both formats.

When we try for XML, we receive error as MessageBodyWriter not found for media type=application/xml, this is because User doesn't have XmlRootElement. Add @XmlRootElement in the user class.


Using HTTP Post
===============

Post
----

-> Post method is used to create records.
-> It is associated with the create function of CRUD functions.
-> POSTs are the workhorse of REST functions, and are the key to submitting data to our backend.

Create an Activity
------------------

-> Create a service to create an activity.
	1. Create ActivityResource - annotate the method with a POST
	
-> Access the method using below URL.
	http://localhost:8080/exercise-services/webapi/activities/activity
	
-> We used the same URL for GET, we will be using the same URL for POST, it's going to be accesses in different methods.


@Consumes
---------

-> We need to tell the POST, what type of information we are consuming. 

How to determine what our method will consume?
-> We use @Consumes annotation with one of the specific types, such as 
	- application/x-www-form-urlencoded
	- application/json
	- application/xml
	
-> @Consumes(MediaType.APLICATION_FORM_URLENCODED)

-> @Produces is used to say what type of information our method would produce. 
-> Consumes is what information we are going to send to this method, and have it consume. We do this by @Consumes annotation, and passing in a type.

-> MediaType.APLICATION_FORM_URLENCODED - syays we'er going to take basic form information from POST, and from a HTML page that's posting to our server, and process that information.

-> Take name value pairs and store it in MultivaluedMap<String, String> formParams.

Ex: Create service to accept form-urlencoded parameters.

Accessing methods:

1. basic HTML form

In the POSTMAN, give URL http://localhost:8080/exercise-services/webapi/activities/activity
dropdown -> POST, Body -> x-www-form-urlencoded

key           value

duration    - 55
description - running
	
When we hit send button, the output is displayed in the console.
running 
55

-> We can send any form-data.

Now create an object from our service.

Output:

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<activity>
    <desc>running</desc>
    <duration>55</duration>
</activity>

Binding to an object
---------------------

-> Binding to an object is much cleaner, and simpler than having all of our parameters stuffed into a string HashMap, a MultivaluedMap.
	- When we store in strings, we need to use Interger.parseInt, or calculate date based on the String that we passed in, al other formats.
	- When we bind the it to an object, it automatically does that for us under the hood. 
-> @Consumes(MediaType.APPLICATION_JSON)
-> Binds to the XML name, so we're using JSOn, it converts our request from a Java object, to XML to JSON or from JSON to XML.
-> We used @XmlRootElement to shorten the name description field to desc, even though we are passing JSOn, we still have to pass desc for that to bind to it, becoz it will use those @XmlElementNames for it binding.

Ex: Demo for binding


@Consumes(MediaType.APPLICATION_JSON) -> Used in Ajax driven app, we've got Javascript submitting to a RESTful service using jQuery, or Angular.

POSTMAN

-> @Consumes(MediaType.APPLICATION_JSON)

So, we can give JSON in postman before sending request

Headers 

Content-type  = application/json

CLick on raw tab

give the json inputs

{
	"duration":55,
	"description":"running"
}

Output in console

null
55

it is null, becoz we are sending description, and that one is expecting desc.

change the json input in postman

{
	"duration":55,
	"desc":"running"
}

console output:

running
55

-> We can use custom binders using various XmlElements for dates.


Build a RESTFul Client in Jersey
================================

-> Restful services are consumed in different ways like browser using javascript like JQuery's JSON features.
-> When building an API, it can be beneficial to procide a client so that we can enforce the contract bewtween the client and the server more easily.

JerseyClient
------------

-> Building a client helps us enforce a contract. In SOAP, the cotract is enforces through WSDL.
-> Generating client everytime people want to use is inefficient, leads to design issues.
-> Jersey has great client capabilities built into it, and it's part of their core framework.
-> Build a client to retrieve an activity, we need to get acitivity id.
 http://localhost:8080/exercise-services/webapi/activities/1234
-> we create ActivityClient class to retieve that activity.
-> Run with Junit.
	1. Add Junit dependency to pom.xml
	2. request(MediaType.APPLICATION_JSON_TYPE)
	
Ex: 

Create ActivityClient class

private Client client; -> Client is provided by Jersey , javax.ws.rs.client.Client

-> We need to define a target that we want to hit, so an endpoint or a URI.

WebTarget target = client.target("http://localhost:8080/exercise-services/webapi/");
Activity response = target.path("activities/"+ id).request().get(Activity.class);

Path -> just appends onto the client target that we've created above.
request() -> says whatever the default type is you want to hand me back, taht's what I'll accept. We can specify JSOn or XML or an object.
get(Activity.class) -> We are getting an Activity object back and it is bind to the Activity class, that's what we are going to store it in the Activity object (response object).

The client is built, now add the dependency in th pom.xml

<dependency>
	<groupId>junit</groupId>
	<artifactId>junit</artifactId>
	<version>4.12</version>
</dependency>

-> junit is now added in our classpath. i.e., we can find it in our Maven dependencies.

Add a JUnit test case for our ActivityClient we created.

Right click on ActivityClient -> New -> JUnit test case 

-> source folder change from exercise-services/src/main/java to exercise-services/src/test/java
-> Click Next -> Select get() method in the ActivityClient class.
-> This creates a stubbed out code for us. 
-> Test case is built up with everythng we need in are basically setup and ready to go.


public class ActivityClientTest {

	@Test
	public void testGet() {
		fail("Not yet implemented");
	}

}

-> JUnit uses a static import. Static import won't be imported through our context sensitive help(ctrl+shft+O). We need to add the static import manually.

assertNotNull(activity); -> Fot this assertion to work, we have to do a static import.

To run it, Right click on ActivityClientTest -> RUn As -> JUnit test -> We should see green bar, 0 Errors
In the console, activity object is returned. We can check the same in the respective path method, by using println.

GET using JSON
--------------

-> To check what is the response, just replace Activity with String 

String response = target.path("activities/"+ id).request(MediaType.APPLICATION_JSON).get(String.class);
System.out.println(response);

Output:

{"desc":"Walking","duration":85,"id":"1234","user":{"id":"5678","name":"Gayathri"}}

Retrieving list of activities
------------------------------

Provide List for activities


public List<Activity> get(){
	
	WebTarget target = client.target("http://localhost:8080/exercise-services/webapi/");
	
	List<Activity> response = target.path("activities").request(MediaType.APPLICATION_JSON).get(List.class);
	
	return response;
	
}

Exception:

MessageBodyProviderNotFoundException

javax.ws.rs.client.ResponseProcessingException: org.glassfish.jersey.message.internal.MessageBodyProviderNotFoundException: MessageBodyReader not found for media type=application/json, type=interface java.util.List, genericType=interface java.util.List.
	

Using Generics in the return type
---------------------------------


1. Returning a list is strange,  
	-> .get(List.class) won't work. Becoz when we add a generics in Java, it broke parsing.
	-> To do this, we need to wrap it with a new Generic Type, and then pass in our Type inside of that. 
	GenericType<List<Actiivty>>(){}
	-> generic type is given by Jersey
	
2. Maps and sets have the same issue.
	-> Any of the objects through collections API, where the've used generics have the same problem inside of our code. 
	

Code change:

	List<Activity> response = target.path("activities").request(MediaType.APPLICATION_JSON).get(new GenericType<List<Activity>>() {});
	
The response object
-------------------

1. HTTP response codes
	-> 200 OK - Good Response (may not be what we are expecting)
	-> 301 - Moved permanently ( Depricated service)
	-> 400 - Bad Request (Missing Information)
	-> 401 - Unauthorized ( no permissions)
	-> 403 Forbidden
	-> 404 Not found ( Objects don't exist)
	-> 500 - Internal Server error ( we should be throwing 500 error from REST API, it means server is down)
	
-> We have the response codes, we return a response object.

Response.status -> creates a ResponseBuilder behind the scenes for us, which builds our Response for us. 

-> If we have our Resonse, we can build the status back that will give us a BAD_REQUEST back to the client, and build that error messages,
	
	
Exception Handling
------------------

@Test
public void testGetWithBadRequest() {
	ActivityClient client = new ActivityClient();
	client.get("123");
}

Throws exception: 

java.lang.RuntimeException: 400: there was an error on the server.
	
Solution:

@Test//(expected=RuntimeException.class)
public void testGetWithBadRequest() {
	ActivityClient client = new ActivityClient();
	client.get("123");
}

To handle null values, add below code

if(activityId.equals("7777")){ // 7777 is just hard coded value instead of database 
	return null;
}

@Test//(expected=RuntimeException.class)
public void testGetWithNotFound() {
	ActivityClient client = new ActivityClient();
	
	client.get("7777");
}

Exception:

java.lang.RuntimeException: 404: there was an error on the server.

Fix:

@Test//(expected=RuntimeException.class)
	public void testGetWithNotFound() {
		ActivityClient client = new ActivityClient();
		
		client.get("7777");
	}
	
POST
----

1. We need to supply an entity to post to the servre.
	-> user .post() method
	-> We use Entity wrapper to say Entity.entity, and pass in the entity want to pass to the server.
		Entity.entity(activity, MediaType.APPLICATION_JSON)

2. Response is same as GET
	-> We can use Response status
	-> return entities
	
	
Ex: 

We are not using id, since we are using POST.
	
	
	public Activity create(Activity activity) {

		// URL will be
		// http://localhost:8080/exercise-services/webapi/activities/activity

		WebTarget target = client.target("http://localhost:8080/exercise-services/webapi/");

		Response response = target.path("activities/activity").request(MediaType.APPLICATION_JSON)
				.post(Entity.entity(activity, MediaType.APPLICATION_JSON));

		if (response.getStatus() != 200) {
			throw new RuntimeException(response.getStatus() + ": there was an error on the server.");
		}

		return response.readEntity(Activity.class);
	}
	
	@Test
	public void testCreate(){
		
		ActivityClient client = new ActivityClient();
		Activity activity = new Activity();
		activity.setDescription("Walking");
		activity.setDuration(85);
		
		client.create(activity);
		
		assertNotNull(activity);
	}
	
Output is displayed in the console:

walking
85

Using HTTP PUT
--------------

-> Used to update records, also used to create records.
-> Associated with update function of CRUD.
-> PUT is least used methods of REST functions when used to submit data to update our services.
-> Developers use POST to create and update records.
-> Put can be used for both functions, certain design considerations should go into API to use PUT.
-> PUT is called idempotent. ( call mutiple times, and shouldn't affect the app. Creates record at first time if it doesn't exist and updates the databas multiple times if it already esists)
-> PUT should be used if we are supplying ID for our object.
-> POST should be used if the server is supplying the ID.

URLs
----

-> POST URL will be like below:
	http://localhost:8080/exercise-services/webapi/activities/activity
	
	There is no ID at the end. POST is a generic URl, server is going to handle the ID for us.
	Each call will create a new object.
	
-> PUT URL will be like below:
	http://localhost:8080/exercise-services/webapi/activities/activity
	
	There is ID at the end. PUT is a specific URL.
	A call will either create or update an object. (idempotent)
	
PUT Client
----------

1. Unit Test
2. CLient code
3. Server
4. Repositoty/stub
	
	
PATCH
-----

-> Used to do partial updates, no annotation called @patch
-> Not built in Jersey yet.
-> No need of sending entire object.
-> 
	
	
	
	
	
	
	
	
	
	
								Creating your first SPring Boot Application
								

Topics:

1. SPring Boot Starters
2. Containerless Deployments
3. Auto-configuration
4. Testing with SpringBoot

Creating First Spring Boot Project
==================================

App name: Das Boot

1. Java 1.8+ for Spring Boot
2. Maven
3. Spring Tool Suite

Demo : App is a basic CRUD app that starts off with a list of shipwrecks.(add/view/update/delete a shipwreck)

-> Create Maven project in STS.  (or) 
-> Create Maven Quickstart archetype from command line. 

Ex: mvn archetype:generate -DgroupId=com.exam.app -DartifactId=exam-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=0.0.1-SNAPSHOT -DinteractiveMode=false

-> Add Spring Boot dependency in pom.xml
In general we add dependencies in dependency section, but for spring boot we add it as parent to our project. 
<parent>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-parent</artifactId>
</parent>
-> Add spring-boot-starter-web dependency - it will integrate Spring MVC and auto configure it for us.

-> com.boot package -> App.java class is created by Maven Quickstart archetype for us.

-> To enable Spring Boot we need to add an annotation called @SpringBootApplication to the top of the class. This annotation scans our project for Spring components and auto-wires up most of the Spring libraries we want to use by enabling auto-configuration.

SpringApplication.run(App.class, args);

-> This line of code fires up Spring Boot when our main method is run as our pure Java application.
-> We need to add Spring MVC Controller, which will handle our root or home URL call on our SPring Boot web application.

-> Create 4 packages in the package com.boot

Controller
model
repository
service

-> Create a class in controller packager, to make it a spring MVC controller by adding @RestController and @RequestMapping URL.

@RestController
public class HomeController {
	
	@RequestMapping("/")
	public String home(){
		return "Das Boot, Gayathri is using Spring Boot!";
	}
	
}

@RequestMapping("/") -> / will identify which mapping it'll take. The method is returning a string that gets returned to the UI, or the caller as the request handler mapping for our root URL.

Start the application -> App.java -> RUn as -> Java application ( no need of using any tomcat)
Browser -> URL: http://localhost:8080 

Output:

Das Boot, Gayathri is using Spring Boot!

Learning Path for Spring Boot
------------------------------

-> Spring Boot can help us break into Java and Spring world by simply using the framework.

1. Use this course
2. note of difficult topics and recheck, debug source code.
3. SPring tutorial reference for examples in http://spring.io
4. Do programs with Google and Stackoverflow

Spring Boot Dependency Management
---------------------------------

-> Spring Boot makes it easier when we want to integrate different libraries and frameworks in our application due to its dependency management structure. 
-> Spring Boot calls its intelligent collection of dependencies the bill of materials - BOM.
-> SPring developers taken time to match up all of the frameworks we may want to include in our application, with appropriate versions that work well with each other.
-> Ex: spring core 4.2.3 matches well with logback-core 1.1.3 
-> By using Spring Boot bill of materials, all these version matches have been setup already for us.
-> Adding dependencies manually needs the right dependency version of libraries that work well with each other. Spring Boot will remove this work.

BOM - working

-> When we added the spring-boot-starter-parent to Maven build file, that parent brought in all of the dependency management.

<parent>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-parent</artifactId>
	<version>1.5.2.RELEASE</version>
</parent>

-> The starter parent also sets up other defaults that are useful for our project, like plugins, java min support version, resource filtering etc.

pom.xml -> Dependency hierarchy tab. (image Dependency Hierarchy)

spring-boot-starter-web -> version 1.5.2  -> This is the dependency we added in pom.xml

-> This pulls in spring-boot, spring-core and a bunch of other transitive dependencies, all with specific versions.
-> No version defined for spring-boot-starter-web dependency, no need to supply the version because the spting-boot-starter-parent defines this dependency and its version for us, and also sets up the correct associated dependencies, and their versions.
-> We can check the versions by changing the version of parent, in dependency hierarchy tab the spring-boot-starter-web version also changes and other versions.
-> SO spring Boot handles all the inticacies of the dependency versions, all by specifying one simple spring-boot-parent version in our build.
-> It is very tedious to define all dependencies one by one in POM file.

Other Spring Boot Initializers
------------------------------

-> Spring provides other tools to make getting started with spring boot even easier.
-> The spring initialixer website, at start.spring.io, is the first tool, it makes easy to generate new project and select bunch of options to get up and running really quick.

Browser -> start.spring.io

-> To create a basic project, we need to fill info, select Spring Boot version and generate the project. To get full details, click on full version. 
-> We have lot of frameworks and libraries to integrate. We can select the respective things like JDBC, h2 ans spring security and generate project.
-> When we generate the project, it's going to create our own Maven based project, bundle up all of the options that we have selected, and download it as .zip file to our computer.

FOr command line

-> Install Spring Boot Command line Interface or CLI.
-> The SPring Boot CLI can initialize a project just like the start.spring.io website does.
-> The command line tools call out to the same back-end API that the website uses, so it's just another way of using spring Initializer, but from command line.

Installing Spring Boot CLI:

-> Several ways we can do

1. Spring Boot docs show how to use SDKMAN, Brew and other ways. 
Link: https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-installing-spring-boot.html

-> Search for Installing Spring Boot CLI, download the zip file. spring-boot-cli-1.5.2.RELEASE-bin.zip
-> If we want command line, chekc the correct version of JDK so that we can run it with the command line. 
-> Once we have downloaded it -> unzip it -> it simple navigates to the unzipped contents in our teminal.
-> ctrl+shft+right click -> open command prompt

*****************************************************************************************************************

C:\Users\gayathri.guttikonda\Desktop\Gayathri\Softwares\spring-boot-cli-1.5.2.RELEASE-bin\spring-1.5.2.RELEASE>ls
'ls' is not recognized as an internal or external command,
operable program or batch file.

C:\Users\gayathri.guttikonda\Desktop\Gayathri\Softwares\spring-boot-cli-1.5.2.RELEASE-bin\spring-1.5.2.RELEASE>dir
 Volume in drive C is OSDisk
 Volume Serial Number is F8E2-95EC

 Directory of C:\Users\gayathri.guttikonda\Desktop\Gayathri\Softwares\spring-boot-cli-1.5.2.RELEASE-bin\spring-1.5.2.RELEASE

03/22/2017  05:58 PM    <DIR>          .
03/22/2017  05:58 PM    <DIR>          ..
03/22/2017  05:58 PM    <DIR>          bin
03/22/2017  05:58 PM             1,413 INSTALL.txt
03/22/2017  05:58 PM    <DIR>          legal
03/22/2017  05:58 PM    <DIR>          lib
03/22/2017  05:58 PM               581 LICENCE.txt
03/22/2017  05:58 PM    <DIR>          shell-completion
               2 File(s)          1,994 bytes
               6 Dir(s)  365,546,635,264 bytes free

C:\Users\gayathri.guttikonda\Desktop\Gayathri\Softwares\spring-boot-cli-1.5.2.RELEASE-bin\spring-1.5.2.RELEASE>cd bin

C:\Users\gayathri.guttikonda\Desktop\Gayathri\Softwares\spring-boot-cli-1.5.2.RELEASE-bin\spring-1.5.2.RELEASE\bin>dir
 Volume in drive C is OSDisk
 Volume Serial Number is F8E2-95EC

 Directory of C:\Users\gayathri.guttikonda\Desktop\Gayathri\Softwares\spring-boot-cli-1.5.2.RELEASE-bin\spring-1.5.2.RELEASE\bin

03/22/2017  05:58 PM    <DIR>          .
03/22/2017  05:58 PM    <DIR>          ..
03/22/2017  05:58 PM             3,001 spring
03/22/2017  05:58 PM             1,948 spring.bat
               2 File(s)          4,949 bytes
               2 Dir(s)  365,546,635,264 bytes free

C:\Users\gayathri.guttikonda\Desktop\Gayathri\Softwares\spring-boot-cli-1.5.2.RELEASE-bin\spring-1.5.2.RELEASE\bin>spring --version
Spring CLI v1.5.2.RELEASE
C:\Users\gayathri.guttikonda\Desktop\Gayathri\Softwares\spring-boot-cli-1.5.2.RELEASE-bin\spring-1.5.2.RELEASE\bin>

******************************************************************************************************************

Create a project usign below command

> spring init --dependencies mySpringBootApp

Using service at https://start.spring.io
Initializr service call failed using 'https://start.spring.io' - service returned Bad Request: 'Unknown dependency 'mySpringBootApp' check project metadata'

-> When we run this, that creates a new folder called mySpringBootApp and places the new initialized project in our current folder that we are running in. 
-> To make it more powerful, we include the spring in the path, so we could call the spring command regardless where we are on the file system.
-> The spring CLI can also be used to run on SPring Boot apps that are Groovy based.

2. We can get an app running up quickly is to simply clone or copy one of the Spring Boot example projects Spring provides on their Github repo. 
-> Once we clone the app, we need to start replacing the exiting code samples with business logic and structures for our project, and we're instantly developing the application. 
Examples:
https://guthub.com/spring-projects/spring-boot/tree/master/spring-boot-samples

-> The website contains lot of integrations, if we want to integrate with Cassandra on SPring Boot or Flyway database migrations, there's lot of options. 
-> We simple browse the projects and find the one we want.
-> warning - in the link spring boot projects typically only show a single integration with a single framework. So if we want more integrations we can go for Spring Initializer or CLI.

How does Spring Boot work?
---------------------------

-> When we created our initial application we didn't deploy our app to a container like Tomcat. we simple ran java main method to start up our app.

3 points

1. Java - main method entry point
	-> The application is started from a java main class using standard public static void main method.
	
2. Spring Application - Spring context, spring environment, Initalizers
	-> Spring Boot Initializes the spring context that comprises our spring app, and then honours any auto-config initializers, configuration and annotations that direct how to initialize and start up the spring context. 

3. Embedded server - Default is tomcat, Auto configured.
	-> An embedded servlet container is started and auto configured.
	-> This is done under os the covers and removes the need for a web.xml.
	-> Spring chosen Tomcat as default servlet container, but there are options to swap out with Jetty, or change configuration options, such as server port.	
	
	
public static void main()   	->    Starts Java and then the applciation.
									  
									  1. It has an argument parameter, and when we start a Java program by typing 
									     java app.class, the JVM initializes and passes control execution to this method.
									  2. The content inside this method are then used to run and perform our 
										 application code and logic.
										 
@SpringBootApplication 			->    A convenience annotation that wraps commonly used annotations with Spring Boot
									  
									  1. This directs Spring Boot how to intialize and start up spring.
									  2. This annotation actually sets up other annotations under the coners, so instead of having to write out each of the other annotations, we can use this one as a convenience annotation.
									  
@Configuration 					->    Spring configuration on startup.
			
									  1. The configuration annotation classigies the Java class we as a 
									     configuration for the spring context that spring Boot and spring will use to initialize and configure various components in environment settings used by Spring. 
									  2. We can think of the configuration annotation as equivalent to the older  
									     Spring XMl based configurations. 
									  3. Instead of using XML to define Spring components, we're going to use Java to define them.
									  								  
@EnableAutoConfiguration 		->    Auto configures framework.
	
									  1. EnableAutoConfiguration is a spring boot-specific annotation. 
									  2. This annotation tells Spring Boot that if it finds any spring subprojects, 
										 or other spring-compatible frameworks on the class path, that it should attempt to auto-configure them and get them wired up and integrate automatically with spring. 
									  3. This single annotation does a lot of the magic of Spring Boot when combined 
									     with the Maven bill of materials the spring-boot-starter-parent provides. 
									  4. When we added the spring-boot-starter-web dependency in our pom.xml file,  
									     that brought in the Spring MVC sub-framework.
									  5. This auto configuration annotation told spring Boot to automatically set 
									     up so we can use spring controllers without having to do any other integration work with that framework.
									  6. It makes setting up a full Java stack app so easy. 
										
@ComponentScan					->	  Scans project for Spring components
									  
									  1. This annotation tells Spring Boot and spring to look for any spring 
									     components, such as controllers, services, repositories or any other spring components, starting in the package of App.java, and recursively looking through all sub packages from there.
									  2. If we place our main app class in a nested subfolder below our other app 
									     folders, the componentScan won't be able to find the spring components.
									  3. It is best to keep the main class at the top level of our main package 
									     structure.
									  
Above three annotations are the main annotations that the SpringBootApplication provides.They are not present explicitely in the code, but they are present.

SpringApplication.run();		->    Starts Spring, creates spring context, applies annotations and sets up 
									  container.
									  
									  1. The SpringApplication boot class is placed in the main method and the 
									     static run method is called. 
									  2. This code intializes our spring context, applies all of the annotation and configuration classes, searches for any spring components, and places them in the spring context, and finally he sets up and configures the embedded container. 

Why move to containerless Deployments
-------------------------------------

What happenes when we deply to a container, such as tomcat or JBoss
-> With a container, we bundle up our application and deploy it to a container running on a server.

	Container
	
	 _______
	|		|
	|  App  |
	|_______|
	
Container Deployments

1. Pre-setup and configuration
	-> The container needs to be setup and configured for each environment.
	-> Ex: stage, test, prod environments, container needs to be configured for each environment.
	-> The process is independent of or actual application and it's like provisioning a database for each of these environments.
	
2. Need to use files like web.xml to tell container how to work. 
	-> For our application to work we need to provide some deployment descriptors so the container understands how to deploy and serve up our application.
	-> This is done with web.xml file, so that the servlet container knows how to set up our application so it can be accessed via the HTTP protocol.

3. Environment configuration is external to our application.
	-> Any application environmental configuration needs to be set up and agreed upon by the application and the container.
	-> This means using JNDI, or container environment properties or settings.
	-> This kind of environmental configuration is external to our application and is configured in the container.
	
		App
	
	 _________
	|		  |
	|Container|
	|_________|
	
	Application Deployments
	
	
1. Runs anywhere Java is setup(like cloud deployments)
	-> When the application is ready for deployment we only need to find an environment that is capable of running the correct version of Java that our app runs on.
	-> This removes any pre-container setup steps and many cloud environments can easily run Java, so deploying to these environments is now quite simple since we can just throw our application .jar file, and it starts running.
	-> We no longer need to find a hosting environment that we can work with that supports something like JBoss, WebLogic, Tomcat or any of the other containers. 
	
2. Container is embedded and the app directs how the container works.
	-> As the container is embedded inside the application we no longer need a deployment descriptor.
	-> web.xml file is gone.
	-> The application along with the SPring Boot, direct the embedded servlet container how to set up the app sp that it can be accessed via the HTTP protocol.
	-> The auto-configuration handles most of this, but we can change behaviour using the Spring Boot property files.
	
3. Environment configuration is internal to application
	-> We are able to run our application as a plain Java app provides some other benefits such as easier debugging and testing.
	-> If for some reason, we can't get away from deploying to a container, we can still deploy Spring Boot apps to a container. 
	
	
Creating Web apps
=================

-> setting up Spring MVC to handle communicating with our web client via a REST API.
-> Spring Boot auto-configures Spring MVC for us. 

points

1. Creating controllers
2. Configure spring MVC with spring boot application properties
3. where to put web-related resources like html, css and javascript 

RESTful Web App
---------------

				Clients												Spring Boot
										HTTP/HTTPS
			(Computer/ Mobile) <--------------------------------->   (App)
		


-> Spring Boot application which we created will be server side of our application.
-> The server side consists of Spring Boot, Spring core and Spring MVC.
-> Spring MVC will provide our RESTful API endpoints that our user interface will communicate with. 
-> We need user interface so our users can actually use our application. 
-> one way to display the UI is browser on computer or mobile that talks to our application via HTTP, or HTTPS protocol.
-> This is a standard client/server architecture that should be familiar to you if you've done any kind of web application programming before.

1. Demo - wiring in our UI client and integrating it with SPring Boot.
		- how to serve client and have it talk back to Spring Boot server.
		- user interface is Angular 1 UI that incorporates Bootstrap for styling.

		
Demo: Integrating a JavaScript Based UI
---------------------------------------

git clone https://github.com/dlbunker/ps-spring-boot-resources.git

Clone/download  from this location.

To know where to put in the spring Boot, Spring Boot has several areas that it will by default serve static content from. 
These areas can be overridden if needed, one default location will suffice.

1. classpath
	- /static
	- /public
	- /resources

Client folder -> contains Angular code, resources and other front end assets. 

client -> www folder -> copy the contents of www folder and paste it in das-boot project -> src/main/resources/public

if resources folder is not present, create it. 

src/main/resources -> is a Maven construct that puts anything in this onto the classpath, so this would be classpath-related resources that are not necessarily java files. 

Create /public folder under src/main/resources -> /public is a location for static content

STS IDE -> das-boot -> right click -> refresh 
					-> right click -> Maven -> update project (to make resources folder to appear, Maven identifies it as a class path resource)
					
src/main/resources -> public folder -> we can find the front end assets

das-boot -> Run as -> Java Application

Browser -> localhost:8080

Output:

Das Boot, Gayathri is using Spring Boot!

http://localhost:8080/index.html 

We can see the UI, with the images and all Das Boot - WWII Shipwreck Dive Locations (Das Boot - image from desktop)

-> We have successfully integrated the UI in spring Boot and it's serving it out. 

UI -> Right click -> Inspect -> COnsole tab -> click on shipwrecks link -> GET http://localhost:8080/api/v1/shipwrecks 404 error

-> This is becoz we haven't setup the back-end Spring MVC controller to handle the Shipwreck API calls. 

Features of Spring Boot's static serving
------------------------------------------

-> If we change the code in client folder, does spring Boot handle it or we need to restart spring Boot to make the changes effected. 

src/main/resources/public/views -> home.html

add a new header <h1>Can I see this change?</h1>

save it and refresh the browser http://localhost:8080/index.html 

We can see the changes, without restarting Spring Boot. 

-> We can also deploy the front-end code separately and setup cores to allow the front end to talk to Spring Boot API. 
-> We can setup Grunt or Gulp to update the UI content in Spring Boot as changes are made to the front end code. 


Demo: Creating Rest End points
------------------------------

-> In the previous demo, we have created client by plugging in the Angular client.
-> We need to provide REST API functionality. 
-> The REST API piece is located in our Spring Boot app, and Spring MVC provides that REST functionality. 
-> It is our entry point in and out of our server for our web client. 

Spring MVC REST COntroller:

-> We use Spring MVC REST Controller to handle the needed API endpoints. 
-> There are 5 endpoints that we need to build out to make the application work with the Angular ngResource. 

-> Each endpoint follows standard RESTful best practices by associating the HTTP verb with a URL to handle the different resource needs such as adding, viewing, deleting, updating shipwrecks in our application. 

We can refer ngResource for  "shipwreck"

- GET /api/v1/shipwrecks(list)
- POST /api/v1/shipwrecks(add)
- GET /api/v1/shipwrecks/{id}(view)
- PUT /api/v1/shipwrecks/{id}(update)
- DELETE /api/v1/shipwrecks/{id}(delete)

Create REST controller

1. @RESTController
2. @RequestMapping("api/v1/") 
	-> The value of api/v1 specifies the base URL that all endpoints will contain for this class. 
	-> In the above URLs, all are starting with /api/v1/, the class level RequestMapping annotation is setting that piece of the endpoint up for us. 
3. @RequestMapping(value = "shipwrecks", method = RequestMethod.GET)
	-> The method level RequestMapping annotation appends its value on to the class level annotation. 
4. similarly for update, view, add, delete

-> Spring Boot handles the integration of Spring MVC, and then it sets up the Jackson Json Library, so that when we send the shpwreck info across the HTTP connection, Spring Boot and Spring MVC are automatically marshalling the JSON info into and out of the shipwreck Java object. 

Restart the app-> run the URL -> Now we have shipwrecks showing upp

Perform add/ delete/ view / update operations

-> If we restart the application, any changes will be lost, but they are persisted in memory in the backend stub for now. 


Spring MVC Integration Overview
-------------------------------

What Spring Boot did to auto-configure and integrate Spring MVC for us. 

1. Spring-boot-starter-web in pom.xml
   -> Spring Boot did more than simply include the Spring MVC.jar on the classpath. 
   -> We also have the auto-configuration enabled with our SpringBootApplication annotation, so Spring Boot goes the extra step and sets up some Spring MVC features for us. 
  
2. Sets up ViewResolvers automatically.
	-> Spring Boot told Spring MVC to set up the content negotiating viewResolver, which determines how to respond based on the content type. Since we're dealing with JSOn payloads, Spring Boot and Spring MVC will setup the Jackson JSON library to handle content negotiation views for our application JSON types. 

3. Sets up static resource sharing
	-> Spring Boot configured and told Spring MVC that it should serve out static resources that are located at the root of the classpath in the static, public, or resources path.

4. Sets up HttpMessageConverter
	-> Spring Boot sets up standard Spring MVC HTTPMessageCOnverters so that it can use sensible defaults to convert JSOn objects into Java ones and vice versa. 
	-> The basic string encoding is set to UTF-8 out of the box by Spring Boot and Spring MVC.
	
5. Sets up customizable hooks
	-> And last, SPring Boot and SPring MVC leave a way that we can override or change any of the default behaviours that gets set up with auto-configuration by leaving us with some programmable, customizable hooks.
	-> These hooks give us full control over how Spring MVC is integrated and we can generally program in any kind of behaviour that we may need. 
	-> These hooks are powerful, but do require us to know more about the framework integrations and are complex. 
	
	
Properties and Environmental configuration
------------------------------------------

application.properties

-> Till now spring boot does auto configuration, if we need to change application that behaves differently than the default Spring Boot gives us, then we can use Spring Boot application properties. 
-> Many of the application settings and behaviour can be adjusted and modified using the application.properties file. 
-> When this file is placed at the root of our classpath, Spring Boot will load it and apply any of the property configurations to your application when your application starts up. 
-> There are other locations that Spring Boot will locate and load your property file.
-> In the Maven-enabled project, it is placed in src/main/resources folder that we placed our static assets for the Angular app. 

Environmental configuration

-> The application properties can also be YAML format-based, instead of the standard Java properties format. 
-> Spring Boot will accept YAML files if we have the SnakeYAML dependency on your classpath. 
-> Application properties change from environment to environment, db credentials change from dev to stage, etc. Spring Boot provides an easy way to handle these changes as we move application from one environment to another. 
-> We can define additional property files that have a profile embedded in the name of the file. 
	application.{profile}.properties
Ex: application.dev.properties -> has dev related configuration in it. 
-> These profile specific property files will be loaded over the main application.property file and any environment-specific properties will be overridden and set for that particular environment.

Demo: Configuring application with properties
=============================================

1. Create application.properties
	-> make sure that it is in the correct place on the classpath so Spring Boot can find it. 
2. Customize embedded container properies
	-> to see how adding simple properites affect the application behaviour. 
3. Setup environment profiles. 
	-> setup application specific property files so we can see how using the spring profiles can run our application differently based on the environment that we are deploying or running in. 
	
-> There is a property which will be able to adjust the logging level in our application so we can debug or figure out what is happening as the application's running. 
-> Just using properties, no need of log4j or other logging-related files. 

logging.level.org.springframework.web=DEBUG

-> It says that it needs to set the logging level for the package org.springframework.web to the DEBUG output.
-> Unti now we were using info logging level, if we change debug we should see more ifnromation about the framework. 
-> We cna place any of the package structures for logging levels.

Now, run the application, we cna see lot of debug statements in the console. Our application.properties was found by SPring Boot and spring. This allowed us to add that property so that too, we can configure the logging levels and change that in our application behaviour. 

-> Server port that is used with the embedded servlet container can be customized .
-> Until now, we were using port 8080 that is the Spring Boot  default. 
   server.port=8181
   http://localhost:8080/index.html#/ -> it will not work
   http://localhost:8181/index.html#/ -> it will work

-> Create application-test.properties, application-prod.properies, Spring Boot won't apply properties from these files unless we specify the actual spring profile. 


application-test.properties -> server.port=9090
application-prod.properies -> server.port=80 -> often applications in production are right on the standard HTTP port 80.

-> When workign with SPring profiles, Spring Boot's going to load all of our main application properties first and then override any environment specific properties as needed. 

Setting up Spring profile
-------------------------

1. Shutdown application
2. Add -D property that defines the profile. 
	-> SPring profiles are part of the core spring project, they're not spring boot specific, but they also tie nively with spring boot becoz of our enviornment-specific files. 
3. Application -> Run configurations -> Arguments -> VM arguments 

	-Dspring.profiles.active=test
	
	test - is the profile that we are trying to run as, matches with application-test.properies file.
	
Run the application 

-> To check if it's using a profile is to look and see what port the app is listening on. 
	Tomcat started on port(s): 9090 (http)
	
Profiles
--------

-> The spring Boot documentation has a list of all the properties that we can adjust at below URL.

https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html

(or) spring boot common application properties

It has all information as how spring boot configures and works with various libraries and frameworks.

Configuring and accessing a data source
=======================================

-> Integration of Spring Boot to a Datasource in an appropriate JDBC driver for our Shipwreck application. 

Identifying frameworks for Integration
--------------------------------------

Architecture (image from desktop)



-> We have a REST API setup with controllers using the Spring MVC framework. 
-> This sits at the top of our server-side stack.
-> We need to tie in JPA and Spring Data JPA so our Spring MVC controllers have a persistence layer they can utilize. 
-> The JPA ORM layer will then talk to a database. (H2 database)
-> H2 database is easy to provision and use, but this could be a MySQL or Oracle or some other relational db.
-> Need FlywayDB framework to handle the ability to version and migrate database structure along with the code.
-> We need to add the Spring Data JPA starter and Spring Boot will auto-configure and set up Spring Data JPA with JPA and all its related libraries pulled in and setup. 
-> The H2 database and FlywayDB libraries are simply dependencies in our Maven POM file.
-> Even though H2 and Flyway aren't actual starters, Spring Boot and Spring will still integrate them and allow us to configure most of those frameworks via the application properties. 


Demo: Provisioning and Integrating a database
---------------------------------------------

-> Integrate H2 database - adding H2 dependency to the Maven POM file.
-> This will include the actual H2-embeddable database and the JDBC sriver support for it. 
-> Add starter dependency as it will detect the H2 database dependency and do some auto-configuration and integration for us. 

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<dependency>
	<groupId>com.h2database</groupId>
	<artifactId>h2</artifactId>
</dependency>

Add above depenencies in pom.xml
Make sure the vm arguments is empty before starting the application. 

-> In the console we can see that dataasbe dialect was set to the H2 dialect, so that means that Spring Boot also detected our H2 database. 
-> At this point we don't have any other views into our embedded database or our frameworks that we added, but Spring Boot provides some configuration properties to help us get an idea of what adding these depenencies really did.

Add below in application.properties

spring.h2.console.enabled=true
spring.h2.console.path=/h2

-> These properties enable the H2 database console in our web app, and allow us to specify the path that we can access it at, which is /h2. 

Restart application -> browser -> localhost:8080/h2

-> h2 console appears and it provides a login with some default values set. 
-> SPring Boot auto-configures the database for us, so we can just login to the console with the default.
-> We actually provisioned our H2 database and got it integrated with our Spring Boot application.

Demo: Configuring a data source
-------------------------------

-> For databases like oracle mysql, we need to provide JDBC details. 
-> With Spring Boot we can configure our Datasource with the application.properties file. 
-> Besides setting the Datassource connection info, SPring Boot also tries to automatically set up our datasource pooling for us. 
-> Database pooling improves db throughput and performance. If spring detects any of the common pooling libraries on our classpath, the auto-configuration will integrate that pool and tie it in with our data source. 
-> When spring-boot-starter-data-jpa dependency was added, that dependency transitively pulled in the tomcat-jdbc pooling librabry.
-> Spring pool uses this pool and its default since it has pretty good performance and concurrency out of the box. 
-> Other pools spring boot will integrate aret he HikariCP, Commons-DBCP, and commons DBCP2.

appliction.properties

spring.datasource.url=jdbc:h2:file:C:/Users/gayathri.guttikonda/Workspace_STS/das-boot/src/main/resources/H2;MV_STORE=FALSE
spring.datasource.username=springBoot
spring.datasource.password=springBoot
spring.datasource.driver-class-name=org.h2.Driver

hibernate.dialect=org.hibernate.dialect.H2Dialect

Above properties define the basics for our database and datasource connection. 
-> Change the URL so that we store our database as a file, database name - Das Boot. 
-> By this way our DB info persists across server restarts as we're testing and developing our application instead of using an in-memeory volatile model.

Restart application -> browser -> localhost:8080/h2

(change the spring-boot-starter-web -> version 1.5.2 to version 1.3.1 if the server doesn't start)

-> We can see the h2 login page, enter the details and login. 
-> Create a new table 

CREATE TABLE TEST(ID INT PRIMARY KEY,
   NAME VARCHAR(255));
   
Created;

-> To make sure that our database is persisting across application restarts, we restart the application and see that the table Test is presisted across application restarts. 
-> If we are using an in-mememory database, our databases will essentially get flushed every time the application restarted. 
-> So, if we want persistence to actually persists, we need to make sure that we are using the file-based databases with the H2 protocol.
-> In the JDBC URL, it specifies file.
jdbc:h2:file:C:/Users/gayathri.guttikonda/Workspace_STS/das-boot/src/main/resources/H2

-> We need different databases for each environment, we can set in application-prod.properies file for production.

application-prod.properies

server.port=9191

spring.h2.console.enabled=true
spring.h2.console.path=/h2

spring.datasource.url=jdbc:h2:file:C:/Users/gayathri.guttikonda/Workspace_STS/das-boot/src/main/resources/H2_prod;MV_STORE=FALSE
spring.datasource.username=prod
spring.datasource.password=prod
spring.datasource.driver-class-name=org.h2.Driver

hibernate.dialect=org.hibernate.dialect.H2Dialect


RunAs -> Arguments -> -Dspring.profiles.active=prod

Browser -> localhost:9191/h2

Login with prod credentials -> Success

Database pooling
----------------

-> The spring-boot-starter-data-jpa dependency that we added also includes tomcat-jdbc pool for us.(check in dependency hierarchy)
-> Since the librabry lives in the classpath, it's being used as our database pool. 
-> So we can configure that by simply adding data base pooling properties. 
-> These properties also have the prefix of spring.datasource, and it allows us to specify some common pooling properties like how many connections are active and idle, wait, evict etc.
-> These settings are environment-specific, so set them for each environments.

spring.datasource.max-active=10
spring.datasource.max-idle=8
spring.datasource.max-wait=10000
spring.datasource.min-evictable-idle-time-millis=1000
spring.datasource.min-idle=8
spring.datasource.time-between-eviction-runs-millis=1


Define shipwreck-appropriate database tables using FlywayDB migration framework.

Demo: Integrating FlywayDB
--------------------------

1. Add the Flyway dependency
	-> To get FlywayDB integrated with the application, add flyway dependency in the classpath.
	-> Spring Boot is good about detecting most libraries and doing some auto-configuration with it, same for flyway.
	
2. COnfigure flyway datasource.
	-> Spring Boot needs to make sure that the datasource is available for flyway. 
	-> Spring Boot typically uses the default datasource we setup, but also have some options to configure and alternative datasource for flyway if we don't want to use the default primary datasource. 
	
3. Create migration scripts
	-> Migrating scripts to modify our database structure. (shipwreck database table be defined and created)

4. Migrate on app startup.
	-> When we startup th application, Flyway will run any outstanding migrations against the database. 
	-> FLyway integrates wiht our core spring Boot app, s migrations simply run and no need to execute the migrations as a separate step. 
	
Create a file V2__create_shipwreck.sql under src/main/resources -> db -> migration folder

-> The reason for starting the migrations at version2 is that flyway baselines at version 1 and migrations start at version 2. 

CREATE TABLE SHIPWRECK(
	ID INT AUTO_INCREMENT,
	NAME VARCHAR(255),
	DESCRIPTION VARCHAR(2000),
	CONDITION VARCHAR(255),
	DEPTH INT,
	LATITUDE DOUBLE,
	LONGITUDE DOUBLE,
	YEAR_DISCOVERED INT
);

-> Flyway SQL is database dependent. The above create table statement will only work for H2 databases.(for oracle it is based on it's syntax)
-> Need to add below property so FLyway can initialize itself properly.

	flyway.baseline-on-migrate=true
	
-> This tells Flyway that if this is the first time that Flyway's ever been run, it should goahead and create the migration metadata table. 
-> Since the application has never been run in our app, this property will make sure that Flyway gets installed and set up correctly. This is why migration script starts at 2, becoz it's going to baseline and create the metadata table as version 1.	

spring.jpa.hibernate.ddl-auto=false

-> Becoz hibernate is running as the entity manager for our JPA tier, it will try to auto-create any entities using the DDL of those entities.
-> We're relying on FLyway to create our database structures and not hibernate.

-> Restart the app and login to H2 db to check if the table is created. 
-> We can see shipwreck table and schema_version - this is the Flyway metadata table that defines what needs to be migrated and what's already been migrated. 
-> Till now we've created some database structures that are relevant to our application by simply including the flyway dependency, adding a migration script, and starting the application.

Spring Boot Java Configuration
------------------------------

1. Define spring beans using Java.
	-> IN older versions of spring, most of the configuration was handled in XML files. We can do the same thing using Java code.
	-> This removes XML from our application and allows us to progammatically handle any kind of app configuration needs that need to take place on app startup.
	-> Instead of relyin on th auto-configuration to setup and build the app datasource, we can create a configuration class and create the DataSource progammatically.
	-> Any configuration Java class that has public methods with the app being annotation will get loaded on app startup and the return values of these methods will then be set as beans inside of the Spring context.
	-> This basic onfiguration lets us add or configure any bean to the spring context.

Why we need to define the datasource progammatically?
-> We may need to define multiple datasources becoz we are talking to multiple databases.
-> We use primary datasource for our JPA code and the secondary datasource for our Flyway migrations.

@Configuration
public class PersistenceConfiguration {
	 
	@Bean
	@ConfigurationProperties(prefix="spring.datasource")
	public DataSource dataSource(){
		return DataSourceBuilder.create().build();
	}
	
}

@Bean -> tells Spring in Spring Boot that the return value of this method which is a DataSource, needs to be setup and stored as a Spring bean in the Spring context.

@ConfigurationProperties(prefix="spring.datasource") -> The configurationProperties annotation tells the DataSourceBuilder to use the connection and pooling properties in the application.properties file where the properties begin with the spring.datasource prefix.

-> We can keep all of the existing connection property definitions that were used with auto-configuration setup, and spring DataSource bean will reuse them.

-> Since, we are adding another datasource, spring needs to know which one is the default when finds ambiguity in wiring up a datasource. This is done by @primary annotation on the Datasource.

@Bean
@ConfigurationProperties(prefix="datasource.flyway")
public DataSource flywaydatasource(){
	return DataSourceBuilder.create().build();
}


add the properties with datasource.flyway

datasource.flyway.url=jdbc:h2:file:C:/Users/gayathri.guttikonda/Workspace_STS/das-boot/src/main/resources/flyway;MV_STORE=FALSE
datasource.flyway.username=flyway
datasource.flyway.password=flyway
datasource.flyway.driver-class-name=org.h2.Driver


-> Creating multiple datasources helps in giving role-based credentials.
-> We need flagging the secondary datasource so that FLyway recognizes it and uses it. Becoz Spring Boot is nice and wants us to imtegrate easily with Flyway, Spring has provided an annotation we can place on our secondary DataSource that flags it for Flyway. That annotation is called @FlywayDataSource.

Restart the application and ensure app starts.

Demo: Adding JPA and Spring Data JPA
------------------------------------

-> We need to add our JPA entity and our SPring Data JPA repository so that our REST controller can use that. 

shipwreck.java -> using it as a DTO object or a transfer object previously. 
			   -> Convert it into an actual JPA entity by adding @Entity
			   
-> We need to tell JPA what attribute of this class is the primary key and how the primary key gets generated.
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	Long id;
	
-> The generated value is saying that the database will take care of incrementing our primary key value for us, so we don't need to pass in a sequence value or some way of generating the primary key. We rely on database engine for that. 
-> The table matches the Java object clearly, so no need of adding @Column.

-> Create a new interface, ShipwreckRepository. As we need it to be a Spring data repository, we extend the JPA repository interface, which takes in the shipwreck entiry, and the primary key type of Long.

-> Till now, we have added our JPA and our SPring Data JPA parts of our persistence tier.

Restart the application and ensure app starts.

Demo: Completing the App
------------------------

-> The persistence tier is built oout of our application, replace the ShipwreckStub in our controller class with the Spring Data ShipwreckRepository, and the app will then complete from the browser all the way down to the database. 

-> Inject the newly-created ShipwreckRepository at the top of the ShipwreckController class by auto-wiring it in and defining the interface.

-> Remove all of the references to the ShipwreckStub and replace them with the ShipwreckRepository.

public class ShipwreckController {
	
	@Autowired
	private ShipwreckRepository shipwreckRepository;
	
	@RequestMapping(value = "shipwrecks", method = RequestMethod.GET)
	public List<Shipwreck> list(){
		return shipwreckRepository.findAll();
	}
	
	@RequestMapping(value = "shipwrecks", method = RequestMethod.POST)
	public Shipwreck create(@RequestBody Shipwreck shipwreck){
		return shipwreckRepository.saveAndFlush(shipwreck);
	}
	
	@RequestMapping(value = "shipwrecks/{id}", method = RequestMethod.GET)
	public Shipwreck get(@PathVariable Long id){
		return shipwreckRepository.getOne(id);
	}
	
	@RequestMapping(value = "shipwrecks/{id}", method = RequestMethod.PUT)
	public Shipwreck update(@PathVariable Long id, @RequestBody Shipwreck shipwreck){
		
		Shipwreck existingShipwreck = shipwreckRepository.findOne(id);
		BeanUtils.copyProperties(shipwreck, existingShipwreck);
		return shipwreckRepository.saveAndFlush(existingShipwreck);
		
	}
	
	
	@RequestMapping(value = "shipwrecks/{id}", method = RequestMethod.DELETE)
	public Shipwreck delete(@PathVariable Long id){
		
		Shipwreck existingShipwreck = shipwreckRepository.findOne(id);
		shipwreckRepository.delete(existingShipwreck);
		return existingShipwreck;
		
	}
	
}


Restart the application and test it.

localhost:8080/index.html

Shipwrecks -> We don't see any dummy data since we are talking to database and the shipwreck table is not having any data in it.

Testing the Spring Boot Project
===============================

Getting started with Spring Boot testing(image from desktop)
----------------------------------------

-> There are several different types of tests that we can write to help test and automate the health of our application.
-> Before testing we need to integrate the testing frameworks.
-> With Spring Boot, we need to add a starter to our project dependencies.
-> For testing we need to add spring-boot-starter-test dependency. This dependency will get us set up with most of our testing needs.

1.  The first framework that test starter will integrate is Junit. 
	-> When doing basic unit testing, JUnit and Spring complement each other well.

2. Even though JUnit provides some assertion support to help analyze test results, Spring Boot also incorporates Hamcrest.
	-> This framework provides improved test result matching and assertions, that when combined with JUnit allow you to automate our testing from start to finish. 

3. The next framework that test starter integrates is Mockito. 
	-> Sometimes when we test, the code we are testing has dependencies on other objects or code that are hard to prop up for a unit test.
	-> In that case, we can use a framework like Mockito to mock and stub those objects so we can proceed wiht our tests, and then verify what was called and used on that mocked object after our test is run. 
	
4. Last, the test starter pulls in Spring Test tools.
	-> These include annotations, test utilities and other testing integration support that allow working with JUnit, Hamcrest and Mockito in a Spring environment. 

	
Demo: Wiring up the Starter and running tests
---------------------------------------------

-> setup environment for testing.

1. Add the spring-boot-starter-test dependency to project's dependencies.
2. Build a unit test to see how it works.
3. Running tests within spring boot.

-> When we created the project using the Maven archetype, that added the JUnit dependency 3.8.1 version. Since the test starter will add JUnit for us, we can remove existing JUnit dependency.

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-test</artifactId>
	<scope>test</scope>
</dependency>

-> This dependency pulls in all test resource dependencies.
-> The scope is test, which means that when the app is bundled and packaged for deployment, any dependencies that are declared with the test scope are ignored. 
-> The test scope dependencies are only available when running in development and Maven test modes. 
-> In the dependency hierarchy tab, the spring-boot-starter-test is grayed out which means it is available only as a test scope.
-> We can also see the 4 main libraries that are transitively pulled in, JUnit, Hamcrest, Mockito and Spring Test. 

-> The Maven archetype that generated the project initially included a test called AppTest. (com.boot package)
-> Modifying AppTest to be first unit test of the applciation as it is outdated.

public class AppTest 
{
	@Test
    public void testApp() {
		
		HomeController hc = new HomeController();
		String result = hc.home();
		assertEquals(result, "Das Boot, Gayathri is using Spring Boot!");
		
    }
}

Run As -> JUnit test
Run As -> Maven test

command line > mvn test 

Demo: Unit Testing with Mockito
-------------------------------

-> ABove unit testing was simple since it was just text. 
-> As apps grow in complexity, we cannot simply unit test in this way, becoz the code we are testing has dependencies on other code that is managed by spring, or is difficult to construct via a test. In that case we can use Mockito. 

public class ShipwreckControllerTest {
	
		@Test
	public void testShipwreckGet() { // goal is to get a shipwreck by its id
		
		ShipwreckController sc = new ShipwreckController();
		Shipwreck wreck = sc.get(1L);
		assertEquals(1L, wreck.getId().longValue());
				
	}
	
}

-> Ultimate goal for this test is to ask for the shipwreck of id1 and get that shipwreck back from the controller. We then run an assertion on the returned object to make sure that the id is equal to 1.

Test failed with NullPointer Exception

-> It appears that the shipwreckRepository is null. becoz, we instaniated the ShipwreckController and didn't use Spring to inject it, so all of the injected objects on the ShipwreckController, like shipwreckRepository, never got created properly by Spring. 
-> This is the exact problem that mock frameworks were created for.
-> By using Mockito, we can mock the shipwreckRepository so we can get out test to work.
-> Instead of instantiating the ShipwreckController, we create a mock instance of it.
-> Mockito provides an annotation that creates this object and injects into the test.

@InjectMocks
private ShipwreckController sc;

@Test
public void testShipwreckGet() { // goal is to get a shipwreck by its id
	Shipwreck wreck = sc.get(1L);
	assertEquals(1L, wreck.getId().longValue());
}

-> Mockito will now manage this object for us. 

-> We need to create a shipwreckRepository mock object so that when we call our controller we don't get that NullPointer Exception. 

@Mock
private ShipwreckRepository shipwreckRepository;

-> Now both objects are managed by Mockito framework.
-> To get Mockito to set that mocked repository automatically on the controller, we need to add a setup init method that initializes all of the mocked objects together when the test runs.

@Before
public void init(){
	MockitoAnnotations.initMocks(this);
}

MockitoAnnotations.initMocks(this); -> When it passes 'this' , it looks at the @InjectMocks and the @Mock attributes, and see if they need to be pushed together. 
-> In our case, since the shipwreckConntroller has a shipwreckRepository on it, the mockito frameowrk will set that for us, much like spring dependency injection. 

-> Specify the mock behaviour on the repository when we call our test. Since we are not actually hitting a database, mock with below lines.


when(shipwreckRepository.findOne(1L)).thenReturn(sw);

-> when method call allows us to provide the actual mocking behaviour. It tells Mockito that when the findOne method is called on the repository, it should return the stubbed shipwreck object.
-> This now allows us to test our controller code as an actual unit text and no need to wired up to database or to spring to make test pass. 
-> The test passes becoz we've mocked the shipwreckRepository.

-> The other cool feature Mockito gives us is the ability to verify that our mocked or stubbed method calls are actually used during the testing of the code. 

To check if the method is called or not.

verify(shipwreckRepository).findOne(1L);
	
-> If for some reason the controller called the findOne method on the repository twice, the test would fail and we could figure out why the method was called twice and fix the issue.

-> We can now test controllers, services or any other kind of objects without having to run an integration test that boots up the Spring Container.
-> Unit tests with mock objects are fast, much faster than integration tests.

Demo: Hamcrest Matchers
-----------------------

-> Hamcrest provides more readable, declarative approach to asserting and matching test results.

assertEquals(1L, wreck.getId().longValue());   // - Mockito

is replaced by

assertThat(wreck.getId(), is(1L));  // Hamcrest

-> This is much more readable and easy to see the ultimate goal of the test assertion.

Integration testing challenges
------------------------------

-> Integration testing is all about testing all pieces of an application working together as they would in a live or production environment. 
-> This means that our application needs to be running to test it. 
-> Becoz of the nature of integration tests, this poses some challenged when building and running these type of tests.

Challenges before spring Boot:

1. Containers are difficult to test
	-> Any code that is part of our application that relies on the container or the servlet application is hard to test becoz we either need to test the startup of the container and run tests against it, or we need to mock the container and emulate it in some way. 

2. Spring Context needs to be available.
	-> Since spring core, spring beans and dependency injection requires Spring to be running and managing those pieces in its application context, all integration tests need to ensure that the spring application context is running. 
	
3. App/ Test startup can be slow.
	-> Starting the spring context and running or emulating the container can take time in larger applciations.
	-> Integration tests run slower than plain unit tests. 

4. Database state needs to be consistent.
	-> If our integration tests are modifying the database, or expecting cerain data in the database to be there for our test case, then we can run into problems if we can;t make the database stay consistent everytime we run the tests. 
	
Spring Boot Apps working:

1. No container, easier to start up.
	-> Becoz spring Boot can be started as a plain Java application, the complexity dealing with a container and deploying our application is removed.
	-> Spring boot has an embedded container, but spring boot simply makes starting and dealing with our app much easier.
	
2. Spring context auto-configuration
	-> Integration tests in spring Boot still need to have a spring Context. 
	-> The main difference between spring Boot and traditional spring apps is the use of starters and auto-configuration.
	-> This makes holding up the spring container with spring boot a little easier.
	
3. App/Test startup can be slow
	-> Integration test startup and execution time are still issues in spring Boot environment.
	-> bigger application - more spring components - more time to start application.
	
4. Database state needs to be consistent.
	-> Database consistency is still an issue with spring boot testing.
	
Demo: Integration Testing
-------------------------

-> To convert any JUnit test into proper integration test, 2 things need to be done

1. Annotate tests with @RunWith annotation and specify that we want to run it with SpringJunit4ClassRunner.

	@RunWith(SpringJunit4ClassRunner.class)
	
2. Add the SpringApplicationConfiguration annotation and provide main spring Boot class for our application.

	@SpringApplicationConfiguration(App.class)
	
	
SpringJunit4ClassRunner -> spring based test class runner, is part of the spring test tools that the test starter transitively 
						   included in the project. 

@SpringApplicationConfiguration(App.class) -> supply main class as annotation parameter, app.class in our application. 
										   -> This tells the spring Boot how to configure and start our application.
										   -> This is like calling main method when we start our app, except that now wew are embedding that inside of the context of a unit test. 
										   
										   
@Test
public void testAll(){
	List<Shipwreck> wrecks = shipwreckRepository.findAll();
	assertThat(wrecks.size(), is(greaterThanOrEqualTo(0)));
}

-> Above test asking the respository for all shipwrecks and then using Hamcrest to make sure that the return list >=0. 
-> When the test starts up the spring ontext will load and spring will inject the full shipwreckRepository into the test similar to running in a standard application.

Demo: Web Integration Testing
-----------------------------

Web Integration test == calling REST API.

-> REST API is prefered than templated JSP page, it's nice to be able to test that actual API. That in turn tests our entire server-side stack. This is the concept of a web integration test. 
-> Spring provides a simple annotation that flags an integration test as web integration test. 
	@WebIntegrationTest
	
	
	

	@Test
	public void testListAll() throws JsonProcessingException, IOException{
		
		RestTemplate restTemplate = new TestRestTemplate();
		
		ResponseEntity<String> response = restTemplate.getForEntity("http://localhost:8080/api/v1/shipwrecks", String.class);
		
		assertThat( response.getStatusCode() , equalTo(HttpStatus.OK));
		
		ObjectMapper objectMapper = new ObjectMapper();
		JsonNode responseJson = objectMapper.readTree(response.getBody());
		
		assertThat( responseJson.isMissingNode(), is(false));
		assertThat( responseJson.toString() , equalTo("[]"));
		
	}


-> Creating RestTemplate, Resttemplates are how we can programatically call APIs, in this case we want to programatically call SHipwreck API. 
-> That API call is asking for all of the shipwrecks that the systsem knows about, and it holds the response. 
-> url can be placed in the application.propertis.
-> Assertion to make sure that we get 200 OK back. If we don't get the 200OK back test will fail immediately.
-> Converting the response into an actual JSON object, and perform some assertions on that to make sure that the return JSON is in a state that makes sense.
-> Since we don't have any shipwrecks in database currently, we check to make sure we get an empty array returned as JSON payload. ([])


Overall Summary
===============

1. create maven project with maven-archetype-quickstart, 1.1
	groupId - com.boot
	artifactId - das-boot
	package - com.boot
2. In pom.xml, add spring boot as parent dependency. 
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>1.3.1.RELEASE</version>
	</parent>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
	</dependency>
3. In App.java class of com.boot package, add @SpringBootApplication at the top of the class, and print below line in the main method.
	SpringApplication.run(App.class, args);
4. Create packages controller, model, respository and service under com.boot.
5. Add spring MVC controller with name HomeController under com.boot.controller and add @RestController at the top of the class.
6. create a method home with @RequestMapping and return string "Das boot reporting for duty";
7. Run App.java class as Java application.
8. In browser, URL : http://localhost:8080
	Output: Das boot reporting for duty


Spring Boot Initializers
------------------------

1. Web Initializer -> easy to create a project

http://start.spring.io -> select desired options and click on generate project -> download zip file

2. Spring Boot CLI -> calls same website start.spring.io and works similar to above (need to be cownloaded)

Create a project usign below command

> spring init --dependencies mySpringBootApp

3 points

1. Java - -> The application is started from a java main class.	
	
2. Spring Application -  Spring Boot Initializes Spring context, spring environment, Initalizers

3. Embedded server - An embedded servlet container is started and auto configured.Default is tomcat, Auto configured.

@SpringBootApplication -> directs Spring Boot how to initialize and start up Spring, sets up other annotations

@Configuration 					->    Spring configuration on startup.
									  								  
@EnableAutoConfiguration 		->    Auto configures framework.
										
@ComponentScan					->	  Scans project for Spring components
									  
Above three annotations are the main annotations that the SpringBootApplication provides.They are not present explicitely in the code, but they are present.

SpringApplication.run();		->    Starts Spring, creates spring context, applies annotations and sets up embedded
									  container.

RestFul Web app
---------------

server side -> Spring Boot, Spring Core and Spring MVC( provides RESTful API endpoints that our user interface will communicate with).
user interface -> web browser, angular 1 UI
client 

clone code from https://github.com/dlbunker/ps-spring-boot-resources.git

-> copy www folder contents in this location to das-boot/src/main/resources/public

setting up UI -> das-boot -> update maven project -> run the application

URL: http://localhost:8080/index.html

output displayed.

-> check the UI changes, put header in home.html and see that in browser.

Build rest api functionality:

-> Rest API is located in Spring Boot app(provided by spring MVC), entry point in and out of server for web client.

5 end points

- GET /api/v1/shipwrecks(list)
- POST /api/v1/shipwrecks(add)
- GET /api/v1/shipwrecks/{id}(view)
- PUT /api/v1/shipwrecks/{id}(update)
- DELETE /api/v1/shipwrecks/{id}(delete)

1. Create ShipwreckController in com.boot.controller package and add @RestController, @RequestMapping("api/v1/") on top of the class.
2. Add a method list add return type List<Shipwreck>, add @RequestMapping(value = "shipwrecks", method = RequestMethod.GET) 
3. Copy Shipwreck class from git code to com.boot.model package and ShipwreckStub class to controller package.
4. return ShipwreckStub.list();
5. Create other end point methods similar to above and return respective methods(create, get, update, delete)
6. Run the application and check the output in browser.

working after adding spring-boot-starter-web in pom.xml, spring boot

1. sets up ViewResolvers - to respond based on content type.
2. sets up static resource serving - located in src/main/resources
3. sets up HttpMessageConverter - convert JSON objects into Java and vice versa.

-> we can override the defaults.

properties -> application.properties placed on classpath root(src/main/resources) and spring boot will load this file and applies properties when application starts.

environment configuration  -> application-{profile}.properties (for db)

1. create application.properties file in src/main/resources and add below code
	logging.level.org.springframework.web=DEBUG
2. run aplication and see if it reflects.
3. changing  server port and check it in browser http://localhost:8181, (change back to 8080)
	server.port=8181
4. Add 2 property files in src/main/resources
	application-test.properties(server.port=9090), application-prod.properties(server.port=80)
5. Run configurations -> Arguments tab : -Dspring.profiles.active=test -> Run

all other properties present in spring docs

Configuring and accessing data source
-------------------------------------

1. add below dependencies in pom.xml

	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-data-jpa</artifactId>
	</dependency>

	<dependency>
		<groupId>com.h2database</groupId>
		<artifactId>h2</artifactId>
	</dependency>
	
2. clear vm arguments in run configurations, run application, hibernate logging statements are seen.
3. In application.properties file, add below code
	spring.h2.console.enabled=true
	spring.h2.console.path=/h2
4. run app and in browser login to h2 database.
	http://localhost:8080/h2
	

Datasource pooling -> tomcat-jdbc is default pooling stratergy 

1. In application.properties file, add below code
	
	spring.datasource.url=jdbc:h2:file:~/dasboot
	spring.datasource.username=sa
	spring.datasource.password=
	spring.datasource.driver-class-name=org.h2.Driver
	
2. Run the application and check in browser
	http://localhost:8080/h2
	enter above credentials and click connect.
3. create a table TEST, relogin and check if that TEST table is present.


-> spring-data-starter-data-jpa includes tomcat-jdbc pool.

1. Add below code for database pooling properties
	
	spring.datasource.max-active=10
	spring.datasource.max-idle=8
	spring.datasource.max-wait=10000
	spring.datasource.min-evictable-idle-time-millis=1000
	spring.datasource.min-idle=8
	spring.datasource.time-between-eviction-runs-millis=1
	

Add Flyway DB
-------------

1. Add below dependency in pom.xml
	
	<dependency>
		<groupId>org.flywaydb</groupId>
		<artifactId>flyway-core</artifactId>
	</dependency>
	
2. create file V2__create_shipwreck.sql under src/main/resources/db/migration, create table inside that.
	CREATE TABLE SHIPWRECK(
		ID INT AUTO_INCREMENT,
		NAME VARCHAR(255),
		DESCRIPTION VARCHAR(2000),
		CONDITION VARCHAR(255),
		DEPTH INT,
		LATTITUDE DOUBLE,
		LONGITUDE DOUBLE,
		YEAR_DISCOVERED INT
	);
3. In application.properties file, add below line
	flyway.baseline-on-migrate=true
	spring.jpa.hibernate.ddl-auto=false;
4. restart application, connect to db and we can find SHIPWRECK table.


Spring Boot Java configuration
------------------------------


1. create config package under com.boot, create class PersistenceConfiguration
	
	@Configuration
	public class PersistenceConfiguration {
		 
		@Bean
		@ConfigurationProperties(prefix="spring.datasource")
		@Primary
		public DataSource dataSource(){
			return DataSourceBuilder.create().build();
		}		
	}

2. create method flywaydatasource similar to above, prefix="datasource.flyway", add @FlywayDataSource
3. In application.properties, add below code
	datasource.flyway.url=jdbc:h2:file:~/flyway
	datasource.flyway.username=flyway
	datasource.flyway.password=
	datasource.flyway.driver-class-name=org.h2.Driver
4. start the app

Adding Spring JPA and Data JPA
------------------------------

1. Add @Entity on Shipwreck class, add @Id and @GeneratedValue(stratergy = GenerationType.AUTO) to Long id;
2. Create interface ShipwreckRepository under com.boot.repository and do extends JpaRepository<Shipwreck, Long>
3. Run the app
4. Replace ShipwreckStub with ShipwreckRepository
5. create reference for ShipwreckRepository in ShipwreckController and add @Autowired to it.
6. replace all shipwreckstub methods with shipwreckRepository.
	list -> findAll(), 
	create(Shipwreck) -> saveAndFlush(shipwreck), 
	get(id) -> findOne(id)
	update(id, shipwreck) -> s1 = findOne(id); BeanUtils.copyProperties(shipwreck, s1), saveAndFlush(s1)
	delete(id) -> s1 = findOne(id); delete(s1);
7. Run app and add new shipwreck, check CRUD operations.

Spring Boot Testing
-------------------

spring-boot-starter-test dependency, below dependencies are pulled in.

Testing frameworks -> Junit, Hamcrest, Mockito, Spring Test

Unit testing with JUnit:

1. In pom.xml remove junit dependency and add below dependency

	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-test</artifactId>
		<scope>test</scope>
	</dependency>
	
2. In AppTest class, remove comments and extends TestCase, keep only testApp()
3. Add @Test annotation to testApp() and create object of HomeController, call home() and do assertEquals("Das-boot, it is starting!");
4. Run the testcase

Unit testing with Mockito:

1. Create class ShipwreckControllerTest in com.boot package in src/test/java
2. Add a method testShipwreckGet with @Test, create a method ShipwreckController, call get(1L), assertEquals(1L, wreck.getId().longValue());
3. The test fails since the dependency ShipwreckRepository is not injected.
4. create reference for ShipwreckController and add @InjectMocks
5. Create reference for ShipwrecckRepository and add @Mock
6. To initialize above ref, create a method init() with @Before and add
	MockitoAnnotations.initMocks(this);
7. In testShipwreckGet(), create Shipwreck object, setId(1L), when(shipwreckRepository.findOne(1L)).thenReturns(sw);

Unit Testing with Hamcrest:

1. In ShipwreckControllerTest class, testShipwreckGet(), replace assertEquals(1L, wreck.getId().longValue()) with 
	assertThat(wreck.getId(), is(1L));
	
Integration testing
-------------------

-> @RunWith(SpringJunit4ClassRunner.class)
-> @SpringApplicationConfiguration

1. Create class ShipwreckRepositoryIntegrationTest in src/test/java com.boot package
2. Add @RunWith(SpringJunit4ClassRunner.class) and @SpringApplicationConfiguration(App.class) annotatons on top of the class.
3. create a method testFindAll() with @Test annotation, call findAll() in shipwreckRepository
	assertThat(wrecks.size(), is(greaterThanOrEqualTo(0)));
4. Autowire shipwrecckRepository object.

Web Integration Test
--------------------

@WebIntegrationTest

-> creating resttemplate for calling APIs
-> if response is 200 OK, then convert the response into JSON object.

1. Create class ShipwreckControllerWebIntegrationtest in src/test/java com.boot package.
2. Add @RunWith and @SpringApplicationConfiguration and @WebIntegrationTest annotations.
3. Add below code:
	
	RestTemplate restTemplate = new TestRestTemplate();
		
	ResponseEntity<String> response = restTemplate.getForEntity("http://localhost:8080/api/v1/shipwrecks", String.class);
	
	assertThat( response.getStatusCode() , equalTo(HttpStatus.OK));
	
	ObjectMapper objectMapper = new ObjectMapper();
	JsonNode responseJson = objectMapper.readTree(response.getBody());
	
	assertThat( responseJson.isMissingNode(), is(false));
	assertThat( responseJson.toString() , equalTo("[]"));







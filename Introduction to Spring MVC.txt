													Introduction to Spring MVC
													==========================

->  Spring MVC is a web application framework for developing applications using Enterprise Java or J2EE.

Which Framework?
----------------

1. Struts -> standard struts 1, outdated. Struts2 is better than original struts.
2. Tapestry -> good framework but governed by 1 person and someone at the WIM or whatever project he is working on.
            -> first heavily object-oriented or POJO-based web frameworks. 
3. Apache Wicket -> light weight framework, easier to configure than other frameworks.
4. GWT -> Google Web Toolkit is a very rich user experience framework with a steeper learning curve than other frameworks.
5. JSF -> JSF from Oracle, true standard framework for the web and J2EE as well, rich user experience. 
	   -> It comes with libraries like ice faces and rich faces and other third party components for integrating into JSF.
6. Seam -> Seam is a JSF framework from the JBoss Group that has other things integrated into it but has a little bit of tendancy to have some 		vendor lock-in associated with it. 
		-> It's nice, tight package but we stuck doing things their way. 
7. Stripes -> a very lightweight web framework that has very similar features to Spring MVC. It's a view technology framework. 
8. Spring MVC -> It is very unobtrusive framework. 
			  -> lightweight, in the sense that there's very little overhead in running it but it's very cabable, heavy duty framework. 
			  -> It puts a lot of the best practices from all of above frameworks mentioned above and combines it into Spring MVC.
			  -> Spring MVC integrates very nicely with Spring and all other capabilities that Spring has available for us to use. 
			  
What is Spring MVC?
------------------

-> Spring MVC doesn't try to niche itself for one particular type of web application. 
-> It can be RESTful-based/ JSP-based. 
-> We can use other view technologies like FreeMarker or Velocity.
-> We can use it for headless applications. 
-> We can use it as a remoting framework. 
-> All these capabilities are built into Spring MVC. 

-> Spring MVC is a web framework built around the principles od Spring.
-> interface driven design, it's very POJO based. 
-> can be unit tested very easily and it's very lightweight, very unobtrusive. 
-> It is based on a Dispatcher servlet/ Front Controller Pattern. 
-> MVC stands for Model view Controller. 
-> It doesn't weigh us down with things we don't need. 
-> Disadvantage of JSF is that it is very heavy weight and we need to do things their way.
-> SPring will just take the things we want and just use those. 
-> Spring MVC is also built from shortcomings of struts1.
-> It supports for 
	1. themes, 
	2. localization, 
	3. Restful services, 
	4. annotation based configuration. (No need of using interfaces and their code if don't want to)
	5. Seamless integration with other spring services/beans.
	

History
-------

2003 

-> Spring framework 1st milestone released. 
-> Focus was on interface-driven development and overcoming the complexities of J2EE development. 

2004 

-> 1.0 release of spring framework.
-> incorporated spring MVC and focused on other areas.
-> integration with common tools like Hibernate and .NET

2006

-> 1.26 version, Jolt productivity award, 
-> SCG/ Spring Securty integrated into the framework.
-> more spring tools

2006

-> 2.0 release, until here things were backward compatible. 

2007

-> 2.5 version, focus on annotation-driven development. 
-> Significant release, as all the configuration was done through annotations, before that it was XML heavy. 

2009

-> 3.0 and 3.1 versions, above things carried on. 
-> Can do configuration using Java, no need of using XML.


Architecture
-----------

-> Spring MVC is built on top of the Java servlet API, implemented using serlvet front controller. 
-> So, spring MVC/ struts or all otherframeworks are just servlets, they got design patterns and things wrapped around it to make it easier. 
-> We write our application on top of Spring MVC or using Spring MVC to build this entire stock. 

				CUSTOM APP
					|
					|
					|
			SPRING MVC/ Spring
					|
					|
					|
			JAVA SERVLETS/JEE


Request/Response life cycle
-----------------------------

-> We have an incoming request that hits our SERVLET FRONT CONTROLLER, just like Dispatcher servlet inside of Spring. 

Servlet Front Controller

-> It hands off the request, delegates our request over to one of our CONTROLLERS that we've set up.

Dispatcher

-> It is the router that comes in and says 
"What controller is going to handle it? I am going to delegate this request over to this controller over here."

Controller 

-> Conrtoller just routes traffic to where it's supposed to go, It says
" I'm going to handle the request and had it over at the backend."

Backend 

-> Backend could be composed of web services or a database or multiple databases or any number of things that we're gathering data from. 
-> Backend hands back a model to us. 

Model 

-> Model is our data, what we're trying to represent on our screen. 

-> Once model gets back to the controller, the controller syas, "ok, I am going to let somebody else do the rendering."
-> rendering is separate from the business logic. 
-> This is called model-view-controller design pattern. Everything is doing its own specified functionality here. 

-> At the controller, we have model or data that we're going to try and represent the UI. 
-> So, we go back to out Front Controller and it says, 
"who's going to handle this? Who's going to render the response? let's pass our model down to some view template."
-> view template can be JSP, once model goes template/JSP page, the control returns back  to our Front Controller and then return back our response to the browser.
-> The whole thing is divided into 3 parts: model, view, controller. 


  Incoming                     Delegate                       Handle
  Request                      request                        Request
-------------->   Front      ------------>   Controller    -----------------> Backend
<-------------- Controller   <---Model-----                <-----------------
  Return           ^  |       Delegate                      Create
  response         |  |       rendering                      Model
				   |  |
                   |  Model
                   |  |
                   |  |
     Return        View            Render
	 Control      Template         Response



Vocabulary
----------

1. Dispatcher Servlet -> The entry/ configuration point for the application. 
                   -> It is also the Front Controller 
	
2. Controller -> Command pattern object that handles the request and determines which view to route to and what model we should get and handles that information and hands it back and forth.
			-> Controllers are simple POJOs.

3. Request Mapping -> The url and request type that our method is tied to. 
                   -> If we accept posts or we accept gets or puts or deletes, those type of HTML protocol requests, then the Request mapping can say, "I only accept posts, I only accept gets."

4. View Resolver -> used to locate the JSP pages or whatever view technology we are using. 
				 -> We configure a view resolver and that's how Spring MVC knows when we ask for the hello page, where to actually find the hello page at.

5. Servlet-config -> it is a configuration file per DispatcherServlet.
				  -> This is where Spring knows to configure things and wire our application up.

6. POJO -> Plain Old Java Object
        -> has no arguments constructor and private member variables, exposed through getters and setters.

7. Bean -> A Spring configured POJO.
        -> It's a POJO that we've instantiated through Spring, in the Servlet-config and it's wired up to be used inside of our framework. 
			  

Summary
-------

1. J2EE based
2. Built around best practice patterns.
3. Stable release cycle.
4. Backwards/forwards compatible.
5. Very active community.
6. Lightweight and unobtrusive
7. Flexible to use with web services, Javascript UI, standard html etc


Building an Application
========================

Prerequisites:
--------------

1. JAVA ( version >= 5)
2. Maven ( version = 3)
3. Spring STS
4. Tomcat


What we are building
-------------------

-> Building app to track the minutes that you have exercised in a day. 

App feautures

1. Allow for entering minutes exercising
2. Show total minutes
3. Set goal for the day
4. Notify when gal is reached.

Getting Spring MVC
-------------------

-> Spring Web flow and Spring web services are not the same thing. 
-> Web flow is a framework built on top of web MVC. 
-> Download spring framework

spring-franework-4.3.3.RELEASE-dist.zip

Maven
-----

-> Using Maven we need only 3 dependencies:

Dependencies

1. spring-webmvc
2. servlet-api
3. jstl

Get the dependencies and use it in pom.xml

While adding dependencies in the pom.xml, 

-> scope for spring-webmvc is compile.
-> scope for servlet-api is provided( provided means don't package it with the WAR file, becoz they are already provided with tomact)
-> scope for jstl is provided.

After adding the dependencies in pom.xml, we get jar files under the Maven dependencies, those are called as transdependencies. 

Spring MVC Configuration
------------------------

There are 4 basic parts we need to configure to utilize Spring MVC in our application.

1. Configure web.xml
2. Configure servlet-config.xml
3. Add Controller
4. Add View

Controller -> is a simple Java class that's annotated

Tomcat
------

-> Tomcat is just a web container. 
-> It doesn't have app server functionality like Oracle, WebSphere. 
-> For most web applications though Tomcat is just fine. 
-> We setup Tomcat server and then FitnessTracker.war will actually reside on top of that. 

			FitnessTracker.war
					|
					|
					|
				 Tomcat 
			  Web Container

Standards
---------

src
	-> main
		-> webapp
			-> WEB-INF
				-> jsps
					-> addTime.jsp
					-> index.jsp
				-> web.xml



-> For views, we put jsp pages or any other view technology under the WEB-INF directory. 
-> The reasons are :

1. security -> don't want people to know what my filename is, we can serve with whatever filename we want. 
2. Control user experience -> don't want people to directly navigate to us. If we force them to go through my controller and through my routing, 
						      we can control their user experience, insuring that their session was set up correctly or that they are logged in,etc.
3. bookmarking/deeplinking -> these are called as breadcrumbs

-> We do this by using InternalResourceViewResolver

InternalResourceViewResolver

-> It says " when I ask for this jsp page, I am goingto find it in this directory and serve it up to them"


addTime.jsp = http://localhost:8080/fitness/addTIme 


Controllers
-----------

1. Annotation based
	-> @Controller
2. Named whatever we want
	-> typically named around business domain.
3. Path set using annotation.
	-> @RequestMapping
4. TimeController.java -> example 

Example URLs associated with Controller

http://localhost:8080/fitness/time
http://localhost:8080/fitness/addTime
http://localhost:8080/fitness/updateTime


web.xml
-------

<servlet></serlvet> -> this is the Spring MVC dispatcher servlet. 

<init-param>

-> tells exact location of the configuration file, i.e., servlet-config.xml
-> By default it creates fitTracker.xml or fitTrackerServletconfig.xml
-> It won't create for us, In web.xml we want to specify where it is and what we want it named just to be clear

<param-name>

-> The param name is contextConfigLocation in CamelCase.  

<param-value>

-> the param value is WEB_INF( caps), config and servlet-config.xml

<servlet-mapping> -> this is what routes traffic through. 

-> The servlet-name inside the <servlet-mapping> tag should be same as the servlet-name in the <servlet> tag

<url-pattern>

-> This specifies what file extensions or what path we're going to accept for our Dispatcher servlet. it is *.html. 


Namespace
---------

-> When configuring servlet-config, specifically our bean configuration or bean definitions, there's notation of namespaces.

Example: 
mvc namespace

<mvc:annotation-driven/>
<context:
>

-> This means that we are asking for specific functionality out of that MVC schema, and it's going to go through and replace theis code with more complex definition. 
-> Spring did this to simplify their configuration files, becoz it was alwyas copy and paste code. 
->  We can add these namespaces from the namespaces tab inside the servlet-config.xml by using Spring Bean configuration file in Spring Tool Suite.
-> For servlet-config.xml we have 3 namespaces

1. beans
2. context
3. mvc

-> When we select them new tabs are created with respective namespaces

<mvc:annotation-driven/>  -> this means we are going to use annotations to configure our application. 

<context:component-scan> -> this means where should we start looking for annotations at? we keep all our controllers underneath the controller
						    package. 
							com.spring.controller
							
Controller
----------

-> Add @Controller at the top of the class.
-> Add @RequestMapping at the top of the method and provide a value. We add @RequestMapping to tie this to the URL. 
Ex: @RequestMapping(value = "/greeting") -> it is tied to /greeting
-> That's what says what our URL is going to be and what method it's going to tie to.

https://localhost:8080/fitnessTracker/greeting is going to tie to this page. 

moel.addAttribute(key, value)
model.addAttribute("wish", "Hi") -> we want to shove/push some things in the model and have that displayed in our UI.

-> We need to put JSP page and the mapping for our JSP page to our controller. 
-> Model is a hash map, basic map structure, it does more than that. 
-> jsp pages are put under WEB-INF directory. 
-> When we create jsp, Spring provides the standard EL language to extract values out of our request parameters.

${greeting} -> points to the key inside the model.addAttribute

-> Those are what tied those together and that's how it knows what to grab out of the model to display on the page. 

-> We need to tell our controller which JSP page to display. So, we need to add bean in servlet-config.xml. 

There are 2 ways to configure the bean.

1. servlet-config.xml

	
	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name = "prefix" value = "/WEB-INF/jsp/"></property>
		<property name = "suffix" value = ".jsp"></property>
	</bean>


-> suffix says where my jsp page is located at and what suffix we are looking for. (value = ".jsp")

2. In the servlet-config.xml, go to namespaces tab and click 'p' - for the property namespace. 

	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" 
	 p:prefix="/WEB-INF/jsp/" p:suffix=".jsp"></bean>
	 
	 This is just shothand for calling getters and setters for prefix and suffix. 


Summary:
--------

1. COnfigured web.xml, In web.xml we added the servlet, the dispathcer servlet and told it where our configuration was at and we mapped all of our incoming requests to .html.
2. We created servlet config.xml. We added namespaces which are convinient methods for us. We also told it that we wanted to do annotation driven and set up our context component scanner. 
3. A context component scanner tells it where to start scanning and for what clases for those annotations. 
4. The first one tells us that we're doing annotation driven. 
5. The second one tells us where those annotations are at. 
6. We created internal resource which syas" where are our jsp pages at?" whenever controller asks for jsp pages, it tells where that file is located at. 
7. We created controller: added source folders, source main java and created controller under com.spring.controller. 
8. HelloController is having controller annotation and a request mapping annotation. Request mapping annotation syays what URL am I going to tie to? 
9. Inside that a method can named whatever we want.We added model object, as an incoming parameter. 
10. Inside of our model we added an attribute for greeting that's going to tie to our jsp page. And then our retun, we told it to go to the hello jsp page. 
11. we created a hello.jsp page and we pulled model here. 

Architecture
------------

-> Architecture of Spring MVC.
-> how Spring MVC fits into the overall framework of spring.

-> Parts of an application can be discussed based around the architecture or design patterns that it's using, and everybody can be on the same page without even having developed on that application before. 

MVC
----

Standard MVC pattern (image)

-> A request comes in through the view based off of some user event and then interpreted by the controller.
-> The controller can change the model or not and then it will select the view based off our action. 
-> From here, the model can update the view with database off of the user's actions. 
-> The graphic stemmed from rich client applications that were more event-based or using a design pattern called observer, observable or a subscriber-listener type design pattern. 
-> This is not applied to all software development, we usually don't have our model updating our view becoz we've gone to a page at that point. 


MVC Web 

	 -------> C <-----------
	|						|
	|						|
	|						|
	|						|
   \|/					   \|/
	M						V

-> This graphic is seen in our web applications. 
-> Our view can access our model but it usually does so through a controller. 
-> We still make a request even if it is a lightweight request through our controller to access our model. 
-> We don't have our view typically going directly against our database or our model.

Tiered Applications
--------------------

Presentation layer
 |          /|\
 |         	 |
\|/			 |
 Business Logic
 |			/|\
 |			 |
\|/			 |
   Data Layer



-> We try to build applications in tiers more now in enterprise languages, 

Reasons are:

1. Separation of concerns

-> It means that each layer is only concerned with the task that it is assigned to do. So, presentation layer is only going to have presentation type things in it, business logic will be contained in a layer, and data/ data access is going to be contained in its own separate layer. 
-> Separation of concerns is not about reuse, its about having things in the right layer so that we can re-architect them later.

2. Reusable layers.

-> It sounds similar to separation of layers but its focus is different. 
-> If we have business logic in Presentations tier, we can't easily change the presentation tier or expose a web service for example without recreating some of that logic. 
-> If we have extracted it into its appropriate tier then we are not duplicating that logic. 
-> If we do copy paste in our application then it's not in correct tier.  
-> Reusable layer means that we have a purpose and a point that we're trying to drive of - we can expose the same data in multiple ways without having to worry about it, or we can replace the presentation tier without having to re-architect the application. 

3. Maintanence/ Refactoring

-> It's the ability to change things without having those changes ripple through all of the code. 
-> If we have hibernate and we have to chnage something in UI based on a change made in hibernate. Ex: table structure. 	
-> If this is done correctly, we can change our code and not have to retest everything rather than the pieces we changed. 

Application Layers
------------------
					View
					(JSPs)
					  |
					  |
					  |
				  Controller
				 (@Controller)
					  |
					  |
					  |
			Data MOdel / Database
			     (Model object)


-> Data model - we would access using hibernate/JDBC or Spring JDBC. This layer represents the data or model of our application. 
-> Controller - interprets the user's request and selects the appropriate view based on what we've requested or what information we got back from data model. 
-> VIew - it can be JSP/ FreeMarker or Velocity.

Myth - Spring MVC is nothing to do with the database. 

-> It has model associated with this. Is model talking about database or model talking about what is framework going represent to JSP page? 
-> It's actually referring to what we are representing in our JSP page but we always have to get that information from somewhre. 

Components
----------



														-------------------> Repository
													   |	 
													   |		
		Controller  ----------------------> Service    --------------------> Repository
					<-----------------------								   |		
													   |
													   --------------------> Repository




We represent the tiers with Spring/ Spring MVC using 3 components.

1. Controller
2. Service
3. Repository													   


Controller  -> Route where we are going and interpret the user's request. 
Service -> where our business logic goes, where our transactions will probably start  if we're accessing more than one database table as well. 
Repository -> Repository is referred to as DAO or Data Access Object. They usually have a 1-1 mapping with out database table. 

Controller
---------

-> they handle our incoming request and bulding the response. 
-> the business logic may/ may not be handled here. 
-> This is where our request and response object should stop.  We dhoulsn;t hand those off to separate tiers.
-> It should grab information from the request and the response and handed over to the business logic. 
-> Works with service and repository tier for business logic and data gathering.
-> Annotated with @Controller. 
-> There are some classes that we can extend but we wither have to wire them up or annotate with controller still. 
-> Handles exceptions and routes the view accordingly. 

Service
-------

-> Annotated with @Service.
-> It describes the verbs (actions) of a system. This is what we are trying to do inside of our application. 
-> where the business logic should reside. It shouldn't bleed into repository tier. 
-> It ensures that the business object is ina valid state. 
-> where transactions often begin(2-phase commits) Ex: roll back or access web services 
-> It often has the same methods as the repository but a different focus. 
Ex: we have method 'find user by lastname' in service tier, and we have same method in repository but what we do if we do't find the user or how many people will return or what state we might return those objects in is controlled by the service tier , whereas the repository tier is just going to get that data. 

Repository
----------

-> Annotated with @Repository
-> It describes the nouns(data) of a system. focus is different from service(verbs/ actions) vs Repository(nouns/data)
-> Focused on persisting and interacting with database or basic CRUD functions.
-> One-to-one mapping with an object. 
-> Often one-to-one mapping with database table. (not always, may break into multiple tables but have only 1 object in application)
 



























